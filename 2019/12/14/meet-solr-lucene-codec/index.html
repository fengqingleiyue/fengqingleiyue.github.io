<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="PFZ6yqxOFdQdNik1n9IHV58-4M7-BgXxFul8LRPCBfE">
<meta name="google-site-verification" content="oOLLlne5ID1zvCYfOmEmCraUcgVCME27VIB4MuKyXYQ">
<meta name="baidu-site-verification" content="rFgOzSpXHJ">
<meta name="msvalidate.01" content="3E8745DAA3A417E7E862430B63AF90E6">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Solr,Lucene,codec,hacking,">





  <link rel="alternate" href="/atom.xml" title="态度决定高度,细节决定成败" type="application/atom+xml">






<meta name="description" content="小试 Solr/Lucene CodecCodec 是什么Lucene 从4.0版本开始提供codec api，简单的来说Lucene通过codec机制来读写索引文件，说白了就是一层数据访问层的api，正常来说我们在使用Lucene/Solr的时候是不用关心这一层细节的，因为默认的codec实现已经经过了大量的细节优化，但是如果你需要修改索引的存储方式，那么codec就是你的入手之处。因为这里涉及">
<meta name="keywords" content="Solr,Lucene,codec,hacking">
<meta property="og:type" content="article">
<meta property="og:title" content="Meet Solr Lucene Codec">
<meta property="og:url" content="https://www.fengqinglei.top/2019/12/14/meet-solr-lucene-codec/index.html">
<meta property="og:site_name" content="态度决定高度,细节决定成败">
<meta property="og:description" content="小试 Solr/Lucene CodecCodec 是什么Lucene 从4.0版本开始提供codec api，简单的来说Lucene通过codec机制来读写索引文件，说白了就是一层数据访问层的api，正常来说我们在使用Lucene/Solr的时候是不用关心这一层细节的，因为默认的codec实现已经经过了大量的细节优化，但是如果你需要修改索引的存储方式，那么codec就是你的入手之处。因为这里涉及">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s2.ax1x.com/2019/12/17/QT8658.png">
<meta property="og:updated_time" content="2019-12-22T16:21:52.105Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Meet Solr Lucene Codec">
<meta name="twitter:description" content="小试 Solr/Lucene CodecCodec 是什么Lucene 从4.0版本开始提供codec api，简单的来说Lucene通过codec机制来读写索引文件，说白了就是一层数据访问层的api，正常来说我们在使用Lucene/Solr的时候是不用关心这一层细节的，因为默认的codec实现已经经过了大量的细节优化，但是如果你需要修改索引的存储方式，那么codec就是你的入手之处。因为这里涉及">
<meta name="twitter:image" content="https://s2.ax1x.com/2019/12/17/QT8658.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.fengqinglei.top/2019/12/14/meet-solr-lucene-codec/">





  <title>Meet Solr Lucene Codec | 态度决定高度,细节决定成败</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">态度决定高度,细节决定成败</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">疯狂的码农</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            留言
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fengqinglei.top/2019/12/14/meet-solr-lucene-codec/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FQL">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="态度决定高度,细节决定成败">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Meet Solr Lucene Codec</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-14T21:05:13+08:00">
                2019-12-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/14/meet-solr-lucene-codec/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/14/meet-solr-lucene-codec/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o">阅读数</i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  34 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="小试-Solr-Lucene-Codec"><a href="#小试-Solr-Lucene-Codec" class="headerlink" title="小试 Solr/Lucene Codec"></a><font color="#0077bb">小试 Solr/Lucene Codec</font></h1><h2 id="Codec-是什么"><a href="#Codec-是什么" class="headerlink" title="Codec 是什么"></a><font color="#2C3E50">Codec 是什么</font></h2><p>Lucene 从4.0版本开始提供codec api，简单的来说Lucene通过codec机制来读写索引文件，说白了就是一层数据访问层的api，正常来说我们在使用Lucene/Solr的时候是不用关心这一层细节的，因为默认的codec实现已经经过了大量的细节优化，但是如果你需要修改索引的存储方式，那么codec就是你的入手之处。<br><strong>因为这里涉及到很多细节，希望大家先不用关心代码细节，而是关注具体的流程和原理，最后对照代码来理解这篇博客,当然如果你还有不明白的地方，欢迎邮件我fengqingleiyue@163.com</strong></p>
<h2 id="自定义Codec"><a href="#自定义Codec" class="headerlink" title="自定义Codec"></a><font color="#2C3E50">自定义Codec</font></h2><p>既然我们知道了codec是什么，那么作为程序员的我们，就会想到-&gt; 我们怎么自定义一个codec呢?<br><a id="more"></a><br>这里为了和笔者所遇到的实际场景相结合，笔者使用Solr(7.7.2)作为例子进行讲解。但在我们开始讲解如何实现自定义codec之前，我们可以看下solr官方文档中的<strong>SimpleTextCodecFactory</strong>,这个codec是Lucene自带的，主要作用其实是通过可读的文本格式用来描述Lucene是怎么存储索引文件的，当然启用的方式也比较简单,修改solrconfig中的SchemaCodecFactory为:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">codecFactory</span> <span class="attr">class</span>=<span class="string">"solr.SimpleTextCodecFactory"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来直接往solr中添加文档就行(这里我们不需要修改任何一行索引代码)，但是这里要注意，因为<strong>SimpleTextCodecFactory</strong>的主要目的是用于演示Lucene是如何存储索引文件的，所以千万不要索引太多的文档(毕竟人家的目的是demo),当索引完成,我们可以查看index目录下的<strong>_XXX_XXX.fld</strong>文件的内容(这里笔者只索引了两个文档，这里看的是.fld文件，当然也可以看其他文件)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">doc 0</span><br><span class="line">  field 0</span><br><span class="line">    name id</span><br><span class="line">    type string</span><br><span class="line">    value 1</span><br><span class="line">  field 1</span><br><span class="line">    name text</span><br><span class="line">    type string</span><br><span class="line">    value 如果想指定结果到特定内存，我们可以使用前面介绍的索引来进行替换操作</span><br><span class="line">  field 2</span><br><span class="line">    name textCNNew</span><br><span class="line">    type string</span><br><span class="line">    value 我们需要先调用attach_grad函数来申请存储梯度所需要的内存</span><br><span class="line">END</span><br><span class="line">checksum 00000000001449379451</span><br></pre></td></tr></table></figure></p>
<p>与使用<strong>SchemaCodecFactory</strong>不同的是，这次我们看到了我们输入的原始内容，但是在<strong>SchemaCodecFactory</strong>的情况下，我们是无法看到这些信息的，因为<strong>SchemaCodecFactory</strong>在存储的时候都是以<strong>二进制形式</strong>，而<strong>SimpleTextCodecFactory</strong>使用的是<strong>文本格式</strong>。到这里我们演示了Lucene自带的<strong>SimpleTextCodec</strong>,相信大家应该对codec有一个比较形象的理解了。那么接下来我们开始实现自己的codec。</p>
<h3 id="自定义DocValuesFormat"><a href="#自定义DocValuesFormat" class="headerlink" title="自定义DocValuesFormat"></a><font color="#2C3E50">自定义DocValuesFormat</font></h3><p>之前我们说过，codec是Lucene读写索引文件的一种机制，而细心的人一定发现Lucene的索引是有很多文件的，即使我们优化了，也绝对不可能只有一个文件，关于Lucene各种文件的描述，大家可以参考<a href="https://lucene.apache.org/core/7_7_2/core/index.html" target="_blank" rel="noopener">Summary of File Extensions</a>,其实codec是一套api，一套对Lucene各种类型文件进行读写的api，而每种不同类型的文件也是由codec中定义的各种Format来实现的，例如,以solr7.7.2中默认的<strong>Lucene70Codec</strong>为例:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>索引文件类型</th>
<th>主要用途</th>
<th>涉及到的文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>FieldInfosFormat</td>
<td>用来Encode/Decode org.apache.lucene.index.FieldInfos,主要是关于文档中文件的信息，如是否索引，是否有payload等信息</td>
<td>.fnm文件</td>
</tr>
<tr>
<td>DocValuesFormat</td>
<td>用来Encodes/decodes per-document values，主要是对每个文档的信息进行编码和解码（Docvalues 其实是一种正排索引）</td>
<td>.dvd &amp; .dvm</td>
</tr>
<tr>
<td>PostingsFormat</td>
<td>用来Encodes/decodes 倒排表，词频，位置等信息</td>
<td>.pos .tip .tim .pay .doc </td>
</tr>
<tr>
<td>…</td>
<td>….</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<p>而Solr中开放了两种最常用的Format,<strong>DocValuesFormat</strong>和<strong>PostingsFormat</strong>供我们进行自定义(其实就是倒排索引和正排索引),这里我们以自定义<strong>DocValuesFormat</strong>来演示如何在Solr中使用我们自定义的DocValuesFormat，废话不多说，我们开始:</p>
<ul>
<li>第一步: 移花接木<br>一般来说Lucene/Solr提供的默认的DocValuesFormat已经经过了大量的代码优化和实战验证，如果不是因为特定的需求，我们一般不会也不需要进行100%的自定义的DocValuesFormat，所以这么为了演示，我们使用”移花接木”的方式来自定义DocValuesFormat-&gt; copy官方的代码然后改掉类名-&gt;然后就是我们自己的了。例如笔者这里自定义了<a href="https://raw.githubusercontent.com/fengqingleiyue/apache-solr-plugins/master/customized-codec/src/main/java/org/fql/codec/docvalues/FqlDocValuesFormat.java" target="_blank" rel="noopener">FqlDocValuesFormat</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fql.codec.docvalues;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.codecs.DocValuesConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.codecs.DocValuesFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.codecs.DocValuesProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.SegmentReadState;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.index.SegmentWriteState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by fengqinglei on 2019/11/27.</span></span><br><span class="line"><span class="comment"> * see &#123;<span class="doctag">@link</span> org.apache.lucene.codecs.lucene70.Lucene70DocValuesFormat&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FqlDocValuesFormat</span> <span class="keyword">extends</span> <span class="title">DocValuesFormat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FqlDocValuesFormat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"Fql"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DocValuesConsumer <span class="title">fieldsConsumer</span><span class="params">(SegmentWriteState state)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FqlDocValuesConsumer(state, DATA_CODEC, DATA_EXTENSION, META_CODEC, META_EXTENSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DocValuesProducer <span class="title">fieldsProducer</span><span class="params">(SegmentReadState state)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FqlDocValuesProducer(state, DATA_CODEC, DATA_EXTENSION, META_CODEC, META_EXTENSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DATA_CODEC = <span class="string">"FqlDocValuesData"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DATA_EXTENSION = <span class="string">"dvd"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String META_CODEC = <span class="string">"FqlDocValuesMetadata"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String META_EXTENSION = <span class="string">"dvm"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION_START = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION_CURRENT = VERSION_START;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// indicates docvalues type</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> NUMERIC = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BINARY = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> SORTED = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> SORTED_SET = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> SORTED_NUMERIC = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DIRECT_MONOTONIC_BLOCK_SHIFT = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMERIC_BLOCK_SHIFT = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMERIC_BLOCK_SIZE = <span class="number">1</span> &lt;&lt; NUMERIC_BLOCK_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMS_DICT_BLOCK_SHIFT = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMS_DICT_BLOCK_SIZE = <span class="number">1</span> &lt;&lt; TERMS_DICT_BLOCK_SHIFT;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMS_DICT_BLOCK_MASK = TERMS_DICT_BLOCK_SIZE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMS_DICT_REVERSE_INDEX_SHIFT = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMS_DICT_REVERSE_INDEX_SIZE = <span class="number">1</span> &lt;&lt; TERMS_DICT_REVERSE_INDEX_SHIFT;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMS_DICT_REVERSE_INDEX_MASK = TERMS_DICT_REVERSE_INDEX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>大家可以和源码对比下，<strong>真的就是copy出来改了下类名</strong>。当然由于Lucene部分代码没有开放public权限，所以我们必须自定义<a href="https://github.com/fengqingleiyue/apache-solr-plugins/blob/master/customized-codec/src/main/java/org/fql/codec/docvalues/FqlDocValuesConsumer.java" target="_blank" rel="noopener">FqlDocValuesConsumer</a>和<a href="https://github.com/fengqingleiyue/apache-solr-plugins/blob/master/customized-codec/src/main/java/org/fql/codec/docvalues/FqlDocValuesProducer.java" target="_blank" rel="noopener">FqlDocValuesProducer</a>,完整的代码可以参考<a href="https://github.com/fengqingleiyue/apache-solr-plugins/tree/master/customized-codec/src/main/java/org/fql/codec/docvalues" target="_blank" rel="noopener">apache-solr-plugins/customized-codec/src/main/java/org/fql/codec/docvalues</a>。</p>
<ul>
<li>第二步: 开启docValues<br>当我们完成了自定义的<strong>FqlDocValuesFormat</strong>之后，我们就可以在solr中启用了，启用的方式也比较简单，可以在solr的官方文档中直接检索<strong>DocValuesFormat</strong>关键字就可以找到相关的用法，这里直接给出改动的点:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"type"</span> <span class="attr">type</span>=<span class="string">"FQL"</span> <span class="attr">indexed</span>=<span class="string">"false"</span> <span class="attr">stored</span>=<span class="string">"false"</span> <span class="attr">required</span>=<span class="string">"true"</span> <span class="attr">multiValued</span>=<span class="string">"false"</span> <span class="attr">docValues</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"FQL"</span> <span class="attr">class</span>=<span class="string">"solr.StrField"</span> <span class="attr">sortMissingLast</span>=<span class="string">"true"</span> <span class="attr">docValuesFormat</span>=<span class="string">"Fql"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里的Fql就是FqlDocValuesFormat#super方法中定义的名称--&gt;</span></span><br></pre></td></tr></table></figure>
<p>很遗憾，当我们打完包放到solr_home的对应的core的lib目录下之后重启Solr会发现在日志中出现以下的错误:<br>(solr_home/CODEC/lib,这里的CODEC就是core的名称,并且这里的jar不需要包含任何依赖)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalArgumentException: An SPI class of type org.apache.lucene.codecs.PostingsFormat with name 'Fql' does not exist.  You need to add the corresponding JAR file supporting this SPI to your classpath.  The current classpath supports the following names: [MockRandom, RAMOnly, LuceneFixedGap, LuceneVarGapFixedInterval, LuceneVarGapDocFreqInterval, TestBloomFilteredLucenePostings, Asserting, BlockTreeOrds, BloomFilter, Direct, FSTOrd50, FST50, Memory, Lucene50, IDVersion, completion]</span><br><span class="line">	at org.apache.lucene.util.NamedSPILoader.lookup(NamedSPILoader.java:<span class="number">116</span>) ~[java/:?]</span><br><span class="line">	at org.apache.lucene.codecs.PostingsFormat.forName(PostingsFormat.java:<span class="number">112</span>) ~[java/:?]</span><br><span class="line">	at org.apache.lucene.codecs.perfield.PerFieldPostingsFormat$FieldsReader.&lt;init&gt;(PerFieldPostingsFormat.java:<span class="number">280</span>) ~[java/:?]</span><br><span class="line">	at org.apache.lucene.codecs.perfield.PerFieldPostingsFormat.fieldsProducer(PerFieldPostingsFormat.java:<span class="number">363</span>) ~[java/:?]</span><br><span class="line">	at org.apache.lucene.index.SegmentCoreReaders.&lt;init&gt;(SegmentCoreReaders.java:<span class="number">113</span>) ~[java/:?]</span><br><span class="line">	at org.apache.lucene.index.SegmentReader.&lt;init&gt;(SegmentReader.java:<span class="number">83</span>) ~[java/:?]</span><br><span class="line">	at org.apache.lucene.index.ReadersAndUpdates.getReader(ReadersAndUpdates.java:<span class="number">172</span>) ~[java/:?]</span><br><span class="line">	at org.apache.lucene.index.ReadersAndUpdates.getReadOnlyClone(ReadersAndUpdates.java:<span class="number">214</span>) ~[java/:?]</span><br><span class="line">	at org.apache.lucene.index.StandardDirectoryReader.open(StandardDirectoryReader.java:<span class="number">106</span>) ~[java/:?]</span><br><span class="line">	at org.apache.lucene.index.IndexWriter.getReader(IndexWriter.java:<span class="number">525</span>) ~[java/:?]</span><br><span class="line">	at org.apache.lucene.index.DirectoryReader.open(DirectoryReader.java:<span class="number">103</span>) ~[java/:?]</span><br><span class="line">	at org.apache.lucene.index.DirectoryReader.open(DirectoryReader.java:<span class="number">79</span>) ~[java/:?]</span><br><span class="line">	at org.apache.solr.core.StandardIndexReaderFactory.newReader(StandardIndexReaderFactory.java:<span class="number">39</span>) ~[java/:?]</span><br><span class="line">	at org.apache.solr.core.SolrCore.openNewSearcher(SolrCore.java:<span class="number">2101</span>) ~[java/:?]</span><br><span class="line">	at org.apache.solr.core.SolrCore.getSearcher(SolrCore.java:<span class="number">2257</span>) ~[java/:?]</span><br><span class="line">	at org.apache.solr.core.SolrCore.initSearcher(SolrCore.java:<span class="number">1106</span>) ~[java/:?]</span><br><span class="line">	at org.apache.solr.core.SolrCore.&lt;init&gt;(SolrCore.java:<span class="number">993</span>) ~[java/:?]</span><br><span class="line">	at org.apache.solr.core.SolrCore.&lt;init&gt;(SolrCore.java:<span class="number">874</span>) ~[java/:?]</span><br><span class="line">	at org.apache.solr.core.CoreContainer.createFromDescriptor(CoreContainer.java:<span class="number">1187</span>) ~[java/:?]</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></p>
<p>这是因为codec采用了java的<a href="https://en.wikipedia.org/wiki/Service_provider_interface" target="_blank" rel="noopener">Service Provider Interface (SPI)</a>来加载，这是为了保证codec可以做成可插拔的模式。当然既然知道为什么出错，解决方案自然也就比较简单了，直接在项目的<strong>resources</strong>目录下建立以下的结构和文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./META-INF</span><br><span class="line">./META-INF/services</span><br><span class="line">./META-INF/services/org.apache.lucene.codecs.DocValuesFormat</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是文件名<strong>org.apache.lucene.codecs.DocValuesFormat</strong>是不可以随便修改的，另外文件<strong>org.apache.lucene.codecs.DocValuesFormat</strong>的内容为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat org.fql.codec.docvalues.FqlDocValuesFormat</span><br><span class="line">org.fql.codec.docvalues.FqlDocValuesFormat</span><br><span class="line"><span class="comment"># 文件的内容就是我们自定义的DocValuesFormat的类完整类名(包含包路径)</span></span><br></pre></td></tr></table></figure></p>
<p>重新打包更新jar包并且重启solr之后会发现之前的错误已经消失了，并且可以通过索引代码更新数据。细心的读者可能会问，貌似我的客户端(index程序)一行代码也没有改，确实，客户端的代码是不需要任何改动的，我去，貌似搞了这么长的时间啥动静也没有，改了这么多有啥用？貌似并不能改变世界…. 是的，但是当你打开索引目录你会发现除了常见的<br><strong>_xx_Lucene70_0.dvd</strong> 和 <strong>_xx_Lucene70_0.dvm</strong>文件，多了 <strong>_xx_Fql_0.dvd</strong> 和 <strong>_xx_Fql_0.dvm</strong>文件，额。。。 貌似还是没啥鸟用。。。  不要着急，下一章就是见证奇迹的时刻!!!</p>
<h2 id="让solr支持按字段更新"><a href="#让solr支持按字段更新" class="headerlink" title="让solr支持按字段更新"></a><font color="#2C3E50">让solr支持按字段更新</font></h2><p>假设你维护的solr有以下几个特点:</p>
<blockquote>
<ul>
<li>对实时没有太高的要求，数据最迟可以按天更新</li>
<li>索引容量庞大(过亿的文档总数，过TB的索引大小，并且每条数据都可能被用户检索到，都是热数据)，为了节约成本，你每次都会将索引优化之后上线</li>
<li>用户的某种设置可以造成万甚至百万级的数据更新，例如用户可以根据已有文档的某个属性某一些值(这里的一些可能是几个也可能是几百个到千个)给已有的几万或者几百万的文档打上标签(其实就是就是增加一个属性)，要求可以检索到这个属性，也可以对这个属性做一维或者二维的分析(solr的facet的功能)，并且这个属性的值是用户手动输入的。</li>
</ul>
</blockquote>
<p>这个需求还是比较变态的，如果我们很有钱，可以怼上几万台机器，管你几百万的更新量，反正给加机器，加到秒回就行了。（现实是我们只有买个位数台服务器的钱，但是还是得满足变态客户的需求)。<br>好吧，既然我们无法做到实时更新，我们只能做近实时或者按照天更新了，那么如果是按照天更新我们该怎么做？大概的解决想法大家肯定能想到:</p>
<ul>
<li>既然有用户的输入的数据，那么我们至少需要一张表来存储用户输入和已有文档属性的映射关系，例如: 假设上面提到某个文档的属性我们成为Field_A，该字段可能取值为a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>…a<sub>n</sub>,用户打上的标签的字段我们称作为CUSTOM_FIELD,那么可能用户可能的操作为，将Field_A值为a<sub>1</sub>,a<sub>100</sub>,a<sub>10000</sub>….a<sub>k</sub>的文档的CUSTOM_FIELD的值定义为:”自定义标签T”,那么一种可能的schema设计为(这里以dynamodb为例子,笔者所在的公司使用的aws的dynamodb服务)</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field_A_VALUE(HashKey)</th>
<th>UserID(RangeKey)</th>
<th>CUSTOM_FIELD_VALUE</th>
</tr>
</thead>
<tbody>
<tr>
<td>a<sub>1</sub></td>
<td>123456</td>
<td>自定义标签T</td>
</tr>
<tr>
<td>a<sub>100</sub></td>
<td>123456</td>
<td>自定义标签T</td>
</tr>
<tr>
<td>…</td>
<td>123456</td>
<td>自定义标签T</td>
</tr>
<tr>
<td>a<sub>K</sub></td>
<td>123456</td>
<td>自定义标签T</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>在每天的数据更新的时候我们通过文档Field_A的值(一般来说这个不会改变,因为是文档的固有属性)，查询上述的表结构,然后将<strong>UserID</strong>和<strong>CUSTOM_FIELD_VALUE</strong>的值拼接起来作为字段CUSTOM_FIELD字段的值，例如可能的<strong>SolrInputDocument</strong>为:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>DocUnique(文档唯一健，与业务强相关)</th>
<th>Field_A</th>
<th>CUSTOM_FIELD</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>a<sub>1</sub></td>
<td>123456_自定义标签T,34553_自定义标签R…</td>
</tr>
<tr>
<td>1</td>
<td>a<sub>k</sub>,a<sub>100</sub></td>
<td>123456_自定义标签T,89882_自定义标签M…</td>
</tr>
</tbody>
</table>
</div>
<p>那么问题来了，为了尽可能的缩小数据更新的范围，我可定得知道哪一些文档会受到用户打上的标签的影响，这时候可能有人会说，这个简单，用户打标签的时候，通过query: Field_A:(a<sub>1</sub> OR a<sub>100</sub> OR ..) 查询后导出不就行了嘛，理论上确实可行，<strong>但是我们在之前的描述中说过，用户打标签这个动作可能会影响几万或者几百万的文档，几万的文档我们还可能导出，但是几百万的文档，我相信几台服务器肯定挂了。</strong>,那么剩下的解决方案只能是全量<strong>更新索引</strong>，如果你维护的索引比较小只有几个GB的话，这种方法确实没有什么不好的，重新更新索引也就是分分钟的事情，但是如果你维护的索引有几个TB的大小，重新做一遍的话可能需要几天或者几十个小时的时间，就算我们复制一份线上的数据到单独的服务器，然后更新用户的标签的变更找到搜到影响的数据，可能这批数据的总量也将近全量的数据了，那么这种情况我们怎么处理？难道我们真的得每天重新更新一下可能有几个TB的索引？</p>
<h3 id="通过Codec单独更新CUSTOM-FIELD字段"><a href="#通过Codec单独更新CUSTOM-FIELD字段" class="headerlink" title="通过Codec单独更新CUSTOM_FIELD字段"></a><font color="#2C3E50">通过Codec单独更新CUSTOM_FIELD字段</font></h3><p>在之前的文章中我们介绍了Lucene的codec，那么我们能不能通过codec的方式来解决问题呢？(<strong>这里给出的解决方案是笔者使用的方式，欢迎大家提出更加完美的解决方案</strong>),我们先来分析分析问题:</p>
<ul>
<li>其实我们需要更新的只有一个CUSTOM_FIELD的字段</li>
<li>这个CUSTOM_FIELD的值是根据Field_A字段生成出来的，而Field_A的数据我们可以通过读索引得到</li>
<li>有没有办法只更新CUSTOM_FIELD字段？</li>
</ul>
<p>当然solr是支持只更新某个字段的，但是前提是其他字段都得存储下来(stored=”true”),如果我们的索引容量比较小的话还是可以这么玩的，但是如果我们维护的是TB级别的索引，所有字段设置stored=”true”估计容量就得翻倍了，本来就没钱买服务器，现在更加。。。。,那么我们有没有办法既能不用存储其他字段也能做到只更新某个字段呢？答案肯定是有的。我们下面来分析下:</p>
<ul>
<li>Solr/Lucene的索引本质实际上就是docid(注意这里的docid是Lucene的唯一健,和Solr的uniquekey注意区分)和term的映射关系，要们倒过来叫倒排索引，要么正过来叫正排索引(docvalues)</li>
<li>所谓的更新数据要们就是删除/修改原来的docid和term的映射关系，也就是说理论上来说如果我们知道这些数据在索引文件中是怎么存储的，我们应该可以重建这样的映射关系然后在覆盖原来的数据<h3 id="爬坑指南"><a href="#爬坑指南" class="headerlink" title="爬坑指南"></a><font color="#2C3E50">爬坑指南</font></h3>之前我们说过，如果我们能知道docid和term的关系是如何在索引中保存的，那么我们就能通过代码按照格式修改/删除docid和term的映射关系，就相当于我们可以只更新某一个字段了,为了能做到只更新某一个字段，我们第一步我们需要将这个字段和其他字段的索引隔离开来</li>
<li>隔离需要单独更新的字段的索引数据<br>这一步比较简单，参考上面的例子，我们可以通过codec来隔离例如:(这里的type字段就是上面我们举的例子的CUSTOM_FIELD字段)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"type"</span> <span class="attr">type</span>=<span class="string">"FQL"</span> <span class="attr">indexed</span>=<span class="string">"false"</span> <span class="attr">stored</span>=<span class="string">"false"</span> <span class="attr">required</span>=<span class="string">"true"</span> <span class="attr">multiValued</span>=<span class="string">"false"</span> <span class="attr">docValues</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"FQL"</span> <span class="attr">class</span>=<span class="string">"solr.StrField"</span> <span class="attr">sortMissingLast</span>=<span class="string">"true"</span> <span class="attr">docValuesFormat</span>=<span class="string">"Fql"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里的Fql就是FqlDocValuesFormat#super方法中定义的名称--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过这样的修改我们就会在优化之后的索引文件中发现多出了_xx_Fql_0.dvd和_xx_Fql_0.dvm,其中dvm是docvalues的metadata信息，dvd文件就是保存docvalues的data信息。而type字段的docvalues数据其实已经和其他的字段的docvalues信息隔离开来了。</p>
<ul>
<li>使用Lucene的代码生成新的索引,这里我们给出伪代码，最终版本的代码比较复杂，我们不再这里亮出<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Directory directory = FSDirectory.open(Paths.get(original_index_location))</span><br><span class="line"><span class="comment">//original_index_location是指我们已经有的索引文件的路径，需要保证已经优化了</span></span><br><span class="line">IndexReader reader = DirectoryReader.open(directory)</span><br><span class="line">Directory newDir = FSDirectory.open(Paths.get(new_index_location))</span><br><span class="line">IndexWriterConfig config = <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> StandardAnalyzer())</span><br><span class="line">config.setUseCompoundFile(<span class="keyword">false</span>);<span class="comment">//因为我们需要读取原始数据，所以必须关闭compoundfile</span></span><br><span class="line">config.setCodec(customCodec);<span class="comment">//使用我们自定义的codec（包含我们自定义的docValuesFormat）</span></span><br><span class="line">config.setOpenMode(IndexWriterConfig.OpenMode.CREATE);<span class="comment">// 创建新索引</span></span><br><span class="line">IndexWriter writer = <span class="keyword">new</span> IndexWriter(newDir,config)</span><br><span class="line"><span class="comment">//new_index_location是指我们要生成的新的索引文件的路径</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;reader.macDoc();i++)&#123;</span><br><span class="line">    Document document = <span class="keyword">new</span> Document();</span><br><span class="line">    <span class="comment">// 这里添加我们的业务代码，主要是给type字段进行赋值</span></span><br><span class="line">    writer.addDocument(document);</span><br><span class="line">&#125;</span><br><span class="line">writer.commit()</span><br><span class="line">writer.forceMerge(<span class="number">1</span>)</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://github.com/fengqingleiyue/apache-solr-plugins/blob/master/customized-codec/src/main/java/org/fql/codec/custom/CustomCodec.java" target="_blank" rel="noopener">customCodec</a></p>
<ul>
<li>使用新的生成的数据覆盖原始索引中对应的文件<br>笔者最开始的时候就直接cat new_index.dvd &gt;old_index.dvd &amp;&amp; new_index.dvm &gt; old_index.dvm,结果发现Solr都无法启动，当然原因也比较简单，是因为Lucene会为生成的索引文件加上一些指纹信息，如果segment的信息和对应的索引文件中的指纹信息不一致，那么就会认为索引文件已经破损。其实就是我们之前说的，我们得知道索引文件是格式是啥，这个我们可以通过读源代码来获取，例如dvd文件的格式我们可以通过查看org.apache.lucene.codecs.lucene70.Lucene70DocValuesProducer的源码了解数据是如何读取的(生成那就是倒过来的步骤)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);</span><br><span class="line"><span class="keyword">this</span>.data = state.directory.openInput(dataName, state.context);</span><br><span class="line"><span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> version2 = CodecUtil.checkIndexHeader(data, dataCodec,</span><br><span class="line">                                                Lucene70DocValuesFormat.VERSION_START,</span><br><span class="line">                                                Lucene70DocValuesFormat.VERSION_CURRENT,</span><br><span class="line">                                                state.segmentInfo.getId(),</span><br><span class="line">                                                state.segmentSuffix);</span><br><span class="line">    <span class="keyword">if</span> (version != version2) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CorruptIndexException(<span class="string">"Format versions mismatch: meta="</span> + version + <span class="string">", data="</span> + version2, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> data file is too costly to verify checksum against all the bytes on open,</span></span><br><span class="line">    <span class="comment">// but for now we at least verify proper structure of the checksum footer: which looks</span></span><br><span class="line">    <span class="comment">// for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption</span></span><br><span class="line">    <span class="comment">// such as file truncation.</span></span><br><span class="line">    CodecUtil.retrieveChecksum(data);</span><br><span class="line"></span><br><span class="line">    success = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    IOUtils.closeWhileHandlingException(<span class="keyword">this</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  .... CodecUtil.checkIndexHeader 为 ....</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkIndexHeader</span><span class="params">(DataInput in, String codec, <span class="keyword">int</span> minVersion, <span class="keyword">int</span> maxVersion, <span class="keyword">byte</span>[] expectedID, String expectedSuffix)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> version = checkHeader(in, codec, minVersion, maxVersion);</span><br><span class="line">checkIndexHeaderID(in, expectedID);</span><br><span class="line">checkIndexHeaderSuffix(in, expectedSuffix);</span><br><span class="line"><span class="keyword">return</span> version;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过源代码我们可以了解到dvd的文件格式为:<br><img src="https://s2.ax1x.com/2019/12/17/QT8658.png" alt="index_file_format.png"><br>这样的话，<strong>我们就可以使用老的索引文件的指纹信息，和新生成的索引文件的数据信息合成一份一新的索引,然后使用新生成的索引文件覆盖老的索引文件</strong>，应该就可以了。那废话不多说，这里放出读取原始(老)索引的指纹信息的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processCodecCheckList</span><span class="params">(IndexInput sourceInput,IndexInput desInput,IndexOutput output)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这里的sourceInput 就是指原始(老)的索引文件</span></span><br><span class="line">        <span class="comment">// 这里的desInput 就是指 新的索引文件 </span></span><br><span class="line">        <span class="comment">// 这里的output就是指最终生成的索引文件</span></span><br><span class="line">        <span class="comment">/* process CODEC_MAGIC*/</span></span><br><span class="line">        output.writeInt(sourceInput.readInt());</span><br><span class="line">        System.out.println(<span class="string">"Skip codec magic "</span>+(desInput.readInt()== CodecUtil.CODEC_MAGIC));</span><br><span class="line">        <span class="comment">/* process codec name*/</span></span><br><span class="line">        output.writeString(sourceInput.readString());</span><br><span class="line">        System.out.println(<span class="string">"Skip codec name "</span> +desInput.readString());</span><br><span class="line">        <span class="comment">/* process codec index version*/</span></span><br><span class="line">        output.writeInt(sourceInput.readInt());</span><br><span class="line">        System.out.println(<span class="string">"Skip codec index version"</span> +desInput.readInt());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** process index header ID (byte array with length 16)</span></span><br><span class="line"><span class="comment">         *  here we need the source index header ID</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">byte</span> id[] = <span class="keyword">new</span> <span class="keyword">byte</span>[StringHelper.ID_LENGTH];</span><br><span class="line">        sourceInput.readBytes(id,<span class="number">0</span>,id.length);</span><br><span class="line">        output.writeBytes(id,id.length);</span><br><span class="line">        desInput.readBytes(id,<span class="number">0</span>,id.length);</span><br><span class="line">        System.out.println(<span class="string">"Skip codec index header id "</span>+StringHelper.idToString(id));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* process the suffix*/</span></span><br><span class="line">        <span class="keyword">byte</span> suffixLength = sourceInput.readByte();</span><br><span class="line">        <span class="keyword">byte</span> suffixBytes[] = <span class="keyword">new</span> <span class="keyword">byte</span> [suffixLength];</span><br><span class="line">        sourceInput.readBytes(suffixBytes,<span class="number">0</span>,suffixBytes.length);</span><br><span class="line">        output.writeByte(suffixLength);</span><br><span class="line">        output.writeBytes(suffixBytes,suffixBytes.length);</span><br><span class="line"></span><br><span class="line">        suffixLength = desInput.readByte();</span><br><span class="line">        suffixBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[suffixLength];</span><br><span class="line">        desInput.readBytes(suffixBytes,<span class="number">0</span>,suffixBytes.length);</span><br><span class="line">        System.out.println(<span class="string">"Skip codec index suffix "</span>+<span class="keyword">new</span> String(suffixBytes,<span class="number">0</span>,suffixLength, StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，我们这里只是使用了索引文件的指纹信息，<strong>具体的索引数据还是需要借用新生成的索引文件</strong>，这里给出部分代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*copy the index data */</span></span><br><span class="line"><span class="keyword">long</span> currentFilePointer = desInput.getFilePointer();</span><br><span class="line"><span class="keyword">while</span>(currentFilePointer!=(desInput.length()-CodecUtil.footerLength()))&#123;</span><br><span class="line">    output.writeByte(desInput.readByte());</span><br><span class="line">    currentFilePointer = desInput.getFilePointer();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"Skip original indexing data"</span>);</span><br><span class="line">currentFilePointer = sourceInput.getFilePointer();</span><br><span class="line"><span class="keyword">while</span>(currentFilePointer!=(sourceInput.length()-CodecUtil.footerLength()))&#123;</span><br><span class="line">    sourceInput.readByte();</span><br><span class="line">    currentFilePointer = sourceInput.getFilePointer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据上面的索引文件格式分析，我们需要覆盖FOOTER_MAGIC,algorithmID和 checksum</span></span><br><span class="line"><span class="comment">/* process FOOTER_MAGIC*/</span></span><br><span class="line">output.writeInt(sourceInput.readInt());</span><br><span class="line"><span class="comment">/* process algorithmID*/</span></span><br><span class="line">output.writeInt(sourceInput.readInt());</span><br><span class="line">output.writeLong(output.getChecksum());</span><br><span class="line">output.close();</span><br><span class="line">sourceInput.close();</span><br><span class="line">desInput.close();</span><br></pre></td></tr></table></figure></p>
<p>很遗憾当我们使用上述的方式通过原始索引文件指纹信息骗过了Solr/Lucene启动时候的文件检查，成功的可以让Solr启动成功，但是当我们运行对<strong>type</strong>字段的查询或者统计的时候(如请求为<a href="http://127.0.0.1:8983/solr/CODEC/select?q=xx&amp;facet=true&amp;facet.field=type)会遇到" target="_blank" rel="noopener">http://127.0.0.1:8983/solr/CODEC/select?q=xx&amp;facet=true&amp;facet.field=type)会遇到</a>: <strong>java.lang.NullPointerException当然如果你非常非常幸运，你也不会遇到</strong>,这里我们先放出错误的信息，然后再解释如果解决这类错误，然后再解释为啥有的时候你不会遇到</p>
<ul>
<li><p>错误信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">58</span>:<span class="number">52.418</span> [qtp752316209-<span class="number">18</span>] ERROR org.apache.solr.handler.RequestHandlerBase - org.apache.solr.common.SolrException: Exception during facet.field: type</span><br><span class="line">	at org.apache.solr.request.SimpleFacets.lambda$getFacetFieldCounts$<span class="number">0</span>(SimpleFacets.java:<span class="number">832</span>)</span><br><span class="line">	at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">	at org.apache.solr.request.SimpleFacets$<span class="number">3</span>.execute(SimpleFacets.java:<span class="number">771</span>)</span><br><span class="line">	at org.apache.solr.request.SimpleFacets.getFacetFieldCounts(SimpleFacets.java:<span class="number">841</span>)</span><br><span class="line">	at org.apache.solr.handler.component.FacetComponent.getFacetCounts(FacetComponent.java:<span class="number">329</span>)</span><br><span class="line">	at org.apache.solr.handler.component.FacetComponent.process(FacetComponent.java:<span class="number">273</span>)</span><br><span class="line">	at org.apache.solr.handler.component.SearchHandler.handleRequestBody(SearchHandler.java:<span class="number">298</span>)</span><br><span class="line">	at org.apache.solr.handler.RequestHandlerBase.handleRequest(RequestHandlerBase.java:<span class="number">199</span>)</span><br><span class="line">	at org.apache.solr.core.SolrCore.execute(SolrCore.java:<span class="number">2551</span>)</span><br><span class="line">	at org.apache.solr.servlet.HttpSolrCall.execute(HttpSolrCall.java:<span class="number">711</span>)</span><br><span class="line">	at org.apache.solr.servlet.HttpSolrCall.call(HttpSolrCall.java:<span class="number">516</span>)</span><br><span class="line">	at org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:<span class="number">395</span>)</span><br><span class="line">	at org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:<span class="number">341</span>)</span><br><span class="line">	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:<span class="number">1602</span>)</span><br><span class="line">	at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:<span class="number">540</span>)</span><br><span class="line">	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:<span class="number">146</span>)</span><br><span class="line">	at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:<span class="number">548</span>)</span><br><span class="line">	at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:<span class="number">132</span>)</span><br><span class="line">	at org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:<span class="number">257</span>)</span><br><span class="line">	at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:<span class="number">1588</span>)</span><br><span class="line">	at org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:<span class="number">255</span>)</span><br><span class="line">	at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:<span class="number">1345</span>)</span><br><span class="line">	at org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:<span class="number">203</span>)</span><br><span class="line">	at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:<span class="number">480</span>)</span><br><span class="line">	at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:<span class="number">1557</span>)</span><br><span class="line">	at org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:<span class="number">201</span>)</span><br><span class="line">	at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:<span class="number">1247</span>)</span><br><span class="line">	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:<span class="number">144</span>)</span><br><span class="line">	at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:<span class="number">132</span>)</span><br><span class="line">	at org.eclipse.jetty.server.Server.handle(Server.java:<span class="number">502</span>)</span><br><span class="line">	at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:<span class="number">364</span>)</span><br><span class="line">	at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:<span class="number">260</span>)</span><br><span class="line">	at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:<span class="number">305</span>)</span><br><span class="line">	at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:<span class="number">103</span>)</span><br><span class="line">	at org.eclipse.jetty.io.ChannelEndPoint$<span class="number">2</span>.run(ChannelEndPoint.java:<span class="number">118</span>)</span><br><span class="line">	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:<span class="number">765</span>)</span><br><span class="line">	at org.eclipse.jetty.util.thread.QueuedThreadPool$<span class="number">2</span>.run(QueuedThreadPool.java:<span class="number">683</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">	at org.fql.codec.docvalues.FqlDocValuesProducer.getSorted(FqlDocValuesProducer.java:<span class="number">785</span>)</span><br><span class="line">	at org.fql.codec.docvalues.FqlDocValuesProducer.getSorted(FqlDocValuesProducer.java:<span class="number">781</span>)</span><br><span class="line">	at org.apache.lucene.codecs.perfield.PerFieldDocValuesFormat$FieldsReader.getSorted(PerFieldDocValuesFormat.java:<span class="number">329</span>)</span><br><span class="line">	at org.apache.lucene.index.CodecReader.getSortedDocValues(CodecReader.java:<span class="number">157</span>)</span><br><span class="line">	at org.apache.solr.uninverting.UninvertingReader.getSortedDocValues(UninvertingReader.java:<span class="number">360</span>)</span><br><span class="line">	at org.apache.lucene.index.FilterLeafReader.getSortedDocValues(FilterLeafReader.java:<span class="number">378</span>)</span><br><span class="line">	at org.apache.lucene.index.MultiDocValues.getSortedValues(MultiDocValues.java:<span class="number">566</span>)</span><br><span class="line">	at org.apache.solr.index.SlowCompositeReaderWrapper.getSortedDocValues(SlowCompositeReaderWrapper.java:<span class="number">141</span>)</span><br><span class="line">	at org.apache.solr.request.DocValuesFacets.getCounts(DocValuesFacets.java:<span class="number">83</span>)</span><br><span class="line">	at org.apache.solr.request.SimpleFacets.getTermCounts(SimpleFacets.java:<span class="number">586</span>)</span><br><span class="line">	at org.apache.solr.request.SimpleFacets.getTermCounts(SimpleFacets.java:<span class="number">426</span>)</span><br><span class="line">	at org.apache.solr.request.SimpleFacets.lambda$getFacetFieldCounts$<span class="number">0</span>(SimpleFacets.java:<span class="number">826</span>)</span><br><span class="line">	... <span class="number">37</span> more</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么会出现这中错误，以及如何解决<br>如果你认真阅读<strong>org.apache.lucene.codecs.lucene70.Lucene70DocValuesConsumer</strong>这个类的源代码，你会发现在每一个<strong>addXXXField</strong>方法(例如<strong>addBinaryField</strong>)方法都会有一个<strong>meta.writeInt(field.number);</strong>的调用，如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBinaryField</span><span class="params">(FieldInfo field, DocValuesProducer valuesProducer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    meta.writeInt(field.number);</span><br><span class="line">    meta.writeByte(Lucene70DocValuesFormat.BINARY);</span><br><span class="line"></span><br><span class="line">    BinaryDocValues values = valuesProducer.getBinary(field);</span><br><span class="line">    <span class="keyword">long</span> start = data.getFilePointer();</span><br><span class="line">    meta.writeLong(start);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其实这非常好解释，Lucene是<strong>面向列存储的</strong>，而每种类型的索引又都存储在一个文件中（优化索引后）,所以各个域需要有唯一标识符来表示，在Lucene中这个唯一标示符号就是<strong>field.number</strong>,所以在我们新生成的索引中，<strong>字段的field.number必须要和原始索引中的字段的field.number保持一致才行</strong>。</p>
<ul>
<li>为什么如果我们运气好的话，这个问题就不会出现?<br>上面讲到了，如果新生成的字段的field.number与原始索引中字段的field.number不一致的话，在试图读取数据的时候就会报<strong>java.lang.NullPointerException</strong>,那么如果字段一致是不是就不会报了呢？ 答案是:确实如此，例如如果我们的索引代码中solrinputDocument中添加字段的顺序为:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SolrInputDocument document = <span class="keyword">new</span> SolrInputDocument();</span><br><span class="line">document.setField(<span class="string">"id"</span>,dataArray[<span class="number">0</span>]); <span class="comment">//字段id 的field.number 为0 </span></span><br><span class="line">document.setField(<span class="string">"type"</span>,dataArray[<span class="number">1</span>]); <span class="comment">// 此时字段type的field.number 为1</span></span><br><span class="line">document.setField(<span class="string">"country"</span>,dataArray[<span class="number">3</span>]);</span><br><span class="line">document.setField(<span class="string">"date"</span>,Integer.valueOf(dataArray[<span class="number">4</span>].replaceAll(<span class="string">"-"</span>,<span class="string">""</span>)));</span><br><span class="line">document.setField(<span class="string">"abstract"</span>,dataArray[<span class="number">5</span>]);</span><br><span class="line">document.setField(<span class="string">"title"</span>,dataArray[<span class="number">6</span>]);</span><br><span class="line">document.setField(<span class="string">"kind"</span>,dataArray[<span class="number">7</span>]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>并且在生成新索引的时候Document中添加字段的顺序为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Document doc = <span class="keyword">new</span> Document();</span><br><span class="line">doc.add(<span class="keyword">new</span> StringField(<span class="string">"id"</span>,String.valueOf(i), Field.Store.YES));</span><br><span class="line">doc.add(<span class="keyword">new</span> StringField(<span class="string">"type"</span>,......)) <span class="comment">// 字段type的field.number 为1</span></span><br></pre></td></tr></table></figure></p>
<p>那么这中场景就是我们说的lucky场景,原始索引和新生成的索引的field.number是一致的，程序不会有任何问题，但是如果我们修改了type字段在代码中出现的顺序那么程序就可能出错了，<strong>实际上Lucene的field.number的生成机制为: 按照字段出现的顺序为每个字段编号，从0到n，在多线程场景中，以优先处理的文档的字段顺序为标准</strong>（这也是为什么我们说如果我们非常非常lucky的话上面的错误我们就不会遇到了）,既然我们知道了原因那么解决方案也比较简单了</p>
<ul>
<li>如果解决此类错误<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step 1, 获得原始索引中的某个字段的field.number</span></span><br><span class="line"><span class="keyword">int</span> number = sourceReader.leaves().get(<span class="number">0</span>).reader().getFieldInfos().fieldInfo(fieldName).number;</span><br><span class="line"><span class="comment">// step 2, 随机添加fake字段使得目标字段的field.number与原始字段一致</span></span><br><span class="line"><span class="keyword">if</span>(isFirstTime)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> fieldNumber=<span class="number">1</span>;fieldNumber&lt;number;fieldNumber++)&#123;</span><br><span class="line">        doc.add( <span class="keyword">new</span> StringField(<span class="string">"xxx_"</span>+fieldNumber,<span class="string">"xxx_"</span>+fieldNumber , Field.Store.NO));</span><br><span class="line">    &#125;</span><br><span class="line">    isFirstTime =<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里解释下为什么fieldNumber要从1开始，其实很简单，因为0被我们代码中的doc.add(new StringField("id",String.valueOf(i), Field.Store.YES)); id 字段使用了，这里的id和uniquekey没有任何关系，如果你把id字段写在添加fake字段的代码后面，那么fieldNumber从0开始也是对的</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当我们补上这些代码之后我们重新生成并覆盖数据之后发现我们可以正常的查询或者统计目标字段了(这里就是type字段)。貌似我们成功了，哈哈，当然不是，如果你只是跟着这篇博客处理个几十条数据，我保证你一辈子都不会遇到下面的问题，但是如果你的索引很大，新索引的生成时间不是1s而是几分钟生成的时候，你就会发现这个坑爹的问题。</p>
<ul>
<li><p>最蛋疼的问题-&gt;数据错位<br>之前我们说过，我们之所以这么做的原因是因为Lucene的本质其实就是docid和term的关系，我们也是通过修改docid和term的关系是现实这种非官方的<strong>按字段更新</strong>,目前为止我们也通过代码生成了新的索引而且通过覆盖原始索引的方式实现的按照字段的更新，那么这里的数据错位打底是指为什么？我们先来回顾下docid是怎么生成的，翻看Lucene的源码你会发现，<strong>Lucene会为每一个接受到的文档赋予一个integer的id，而这个id就是docid</strong>,这里再强调以下，Lucene中并没有类似solr的UniqueKey这种东西，docid才是Lucene的唯一键，docid标识了每一个document(即使document的内容没有任何差别),而在实际应用中，我们几乎不会将docid放到业务中使用和存储—&gt; 因为docid会发生变化—&gt; ???? 说好的唯一键呢，唯一键都变了这是要闹哪样，尼玛坑爹中的战斗机啊。。。。。</p>
<ul>
<li>为什么唯一键会变?<br>了解Lucene的原理的人都知道，Lucene在写入数据的时候是写入内存的，当内存满了或者其他条件达到了，Lucene会将内存中的文件刷到磁盘上并称为一个segment，那么如果文档非常多的话，就会有非常多的段，所以Lucene又有一个merge的操作，类似于后台线程，不断将新生成的segment合并成一个新的大的段来保持段的数量在合理的范围，因为段太多会导致查询速度不断的降低。而docid的改变就发生在segment的合并中（具体个变化和merge policy有关，我会在另外一篇文章中详细介绍）</li>
<li>唯一键变了会有什么影响<br>注意到新生成的索引文件是按照docid的顺序读取的，而且是单线程的，也就是说我们通过这种方式来使得新加入的数据的docid和原始的docid保持一致，而达到数据修改和替换的目的，但是由于Lucene并没有在api成面给我们设置或修改docid，所以我们只能在添加文档的顺序上来模拟内部的docid的顺序从而保证我们的机制能够运行，但是我们忘记了一个重要的索引生成过程—&gt; segment的合并过程，Lucene 7默认的合并策略是<strong>TieredMergePolicy</strong>,而这个合并策略并不能保证<strong>相邻的段会合并</strong> (如果不是相邻的段合并，那么docid可能就被在合并的过程中被改变),所以唯一键的改变会导致成<strong>数据错位</strong> </li>
<li><p>如何解决数据错位的问题<br>既然我们知道了原因，那么解决方案就比较简单，Lucene中的<strong>LogByteSizeMergePolicy</strong>可以保证永远都是合并相邻的segments，具体为什么是LogByteSizeMergePolicy,我会在后续的文章中给出解释，目前大家可以记住LogByteSizeMergePolicy可以保证段的合并是相邻的进行合并,代码改动点则为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IndexWriterConfig writerConfig = <span class="keyword">new</span> IndexWriterConfig();</span><br><span class="line">writerConfig.setUseCompoundFile(<span class="keyword">false</span>);</span><br><span class="line">writerConfig.setCodec(customCodec);</span><br><span class="line">writerConfig.setOpenMode(IndexWriterConfig.OpenMode.CREATE);</span><br><span class="line"><span class="comment">/*we need use LogMergePolicy since we need keep the doc Order */</span></span><br><span class="line">writerConfig.setMergePolicy(<span class="keyword">new</span> LogByteSizeMergePolicy());</span><br></pre></td></tr></table></figure>
<p>到这里我们才完成了所有的改动点，也使用了这种黑科技的方法做到了solr按照字段更新。</p>
</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font color="#2C3E50">总结</font></h2><ul>
<li>codec是Lucene用开控制索引读写的一层api，如果我们要自定义索引的格式，我们可以通过自定义的codec来实现</li>
<li>这里介绍的<strong>Solr按字段更新数据</strong>并不是solr官方的方式，这其实是一种黑科技，我们先在来梳理下这个黑科技是如何想到的，并且如何一步一步的解决其中的坑的<ul>
<li>我们想出这种类似<strong>移花接木</strong>的方案的根本来源是因为Lucene的索引文件的本质就是存储了docid和term的映射关系</li>
<li>刚开始的时候我们什么指纹信息都没有改动，直接使用新索引覆盖原始索引，这才发现了原来lucene写入了这些指纹信息来方式索引文件发生损坏，其实这里少了一步，最早的时候笔者是使用<strong>SimpleTextCodecFactory</strong>来测试的，而这个codec不会写入任何指纹信息，所以刚开始直接覆盖没有任何问题，直接成功了，这也是为什么后来再改动codec之后上来就直接使用文件覆盖的方式来验证想法的原因，虽然这是最笨的方式，确实能够暴露问题</li>
<li>field.number的信息也不算隐蔽，但是当我们hack了指纹信息以为万事大吉的时候，最终的查询还是告诉我们，还有信息没有注意到。</li>
<li>Merge的问题确实是最难发现的，如果数据容量不到一定规模，根本不会发现问题，因为测试的时候笔者使用的数量很少，这也是当时困扰笔者最长的时间的一个细节点，很隐蔽，但是经过大量的源码debug还是发现了问题所在并且成功了解决了现实业务中的问题。</li>
</ul>
</li>
<li>由于篇幅关系，笔者没有直接复制粘贴所有的代码，而是希望通过各种关节点的描述来分享给问题是什么，笔者是如何想到解决方案的，在实施解决方案中的关键问题是什么，笔者相信，知道为什么比知道怎么做更加重要。</li>
<li>所有的代码可以在<a href="https://github.com/fengqingleiyue/apache-solr-plugins/tree/master/customized-codec" target="_blank" rel="noopener">customized-codec</a>找到，可以使用<a href="https://github.com/fengqingleiyue/apache-solr-plugins/blob/master/customized-codec/src/main/resources/demo/demo.sh" target="_blank" rel="noopener">demo.sh</a>来进行本地环境的复现。这里给一些简单的说明<ul>
<li>测试的数据是<a href="http://s3.amazonaws.com/data.patentsview.org/20191008/download/patent.tsv.zip" target="_blank" rel="noopener">patent.tsv.zip</a>总条数大概是7百万条</li>
<li>测试在centos环境中验证通过，其他环境欢迎大家尝试</li>
<li>为了代码简单，我这里的修改只是将原始索引的某个字段(type字段)的值修改成了另外一个值(将utility改成了fql_demo)</li>
<li>本篇博客中只描述了DocValuesFormat的hack方式，其实solr中的PostingsFormat也可以按照相同的方式进行hack，笔者给的例子就是同时自定了DocValuesFormat和PostingsFormat。基本上这两个Format解决了查询和分析的需求。<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><font color="#2C3E50">参考文章</font></h2></li>
</ul>
</li>
<li><a href="https://www.elastic.co/blog/what-is-an-apache-lucene-codec" target="_blank" rel="noopener">https://www.elastic.co/blog/what-is-an-apache-lucene-codec</a></li>
<li><a href="https://en.wikipedia.org/wiki/Service_provider_interface" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Service_provider_interface</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Solr/" rel="tag"># Solr</a>
          
            <a href="/tags/Lucene/" rel="tag"># Lucene</a>
          
            <a href="/tags/codec/" rel="tag"># codec</a>
          
            <a href="/tags/hacking/" rel="tag"># hacking</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/28/text-retrieval-and-search-engines-4/" rel="next" title="Text Retrieval and Search Engines 4">
                <i class="fa fa-chevron-left"></i> Text Retrieval and Search Engines 4
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="FQL">
            
              <p class="site-author-name" itemprop="name">FQL</p>
              <p class="site-description motion-element" itemprop="description">一个专注为什么的博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/fengqingleiyue" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:fengqingleiyue@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#小试-Solr-Lucene-Codec"><span class="nav-number">1.</span> <span class="nav-text">小试 Solr/Lucene Codec</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Codec-是什么"><span class="nav-number">1.1.</span> <span class="nav-text">Codec 是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义Codec"><span class="nav-number">1.2.</span> <span class="nav-text">自定义Codec</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义DocValuesFormat"><span class="nav-number">1.2.1.</span> <span class="nav-text">自定义DocValuesFormat</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#让solr支持按字段更新"><span class="nav-number">1.3.</span> <span class="nav-text">让solr支持按字段更新</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通过Codec单独更新CUSTOM-FIELD字段"><span class="nav-number">1.3.1.</span> <span class="nav-text">通过Codec单独更新CUSTOM_FIELD字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#爬坑指南"><span class="nav-number">1.3.2.</span> <span class="nav-text">爬坑指南</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文章"><span class="nav-number">1.5.</span> <span class="nav-text">参考文章</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FQL</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user">访客数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye">总访问量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '6yXMwb5kTOh8sbk3lEsbXRaK-gzGzoHsz',
        appKey: '5D7N6FwrI3BWypsetbgVVOX7',
        placeholder: '来吧,造作吧!!!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
