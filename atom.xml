<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>态度决定高度,细节决定成败</title>
  
  <subtitle>疯狂的码农</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.fengqinglei.top/"/>
  <updated>2019-10-02T13:30:20.684Z</updated>
  <id>https://www.fengqinglei.top/</id>
  
  <author>
    <name>FQL</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>玩转Solr源码之(二)Solr源码Debug</title>
    <link href="https://www.fengqinglei.top/2019/10/01/solr-source-code-debug/"/>
    <id>https://www.fengqinglei.top/2019/10/01/solr-source-code-debug/</id>
    <published>2019-10-01T14:19:40.000Z</published>
    <updated>2019-10-02T13:30:20.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="玩转Solr源码之–Solr源码Debug"><a href="#玩转Solr源码之–Solr源码Debug" class="headerlink" title="玩转Solr源码之–Solr源码Debug"></a><font color="#0077bb">玩转Solr源码之–Solr源码Debug</font></h1><p>这篇文章是<strong>玩转Solr源码</strong>系列的第二篇，紧接着上一篇的<a href="http://www.fengqinglei.top/2019/10/01/solr-source-code-import/" target="_blank" rel="noopener">源码导入</a>，如果你还对如何将Solr源码导入到IDE还不了解的话，建议先看<strong>源码导入</strong>的部分。</p><h2 id="定位源码入口"><a href="#定位源码入口" class="headerlink" title="定位源码入口"></a><font color="#2C3E50">定位源码入口</font></h2><p>Solr 的源码入口为<strong>org.apache.solr.client.solrj.StartSolrJetty</strong>,主方法也比较简短,<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//System.setProperty("solr.solr.home", "../../../example/solr");</span></span><br><span class="line"></span><br><span class="line">    Server server = <span class="keyword">new</span> Server();</span><br><span class="line">    ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, <span class="keyword">new</span> HttpConnectionFactory());</span><br><span class="line">    <span class="comment">// Set some timeout options to make debugging easier.</span></span><br><span class="line">    connector.setIdleTimeout(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">    connector.setSoLingerTime(-<span class="number">1</span>);</span><br><span class="line">    connector.setPort(<span class="number">8983</span>);</span><br><span class="line">    server.setConnectors(<span class="keyword">new</span> Connector[] &#123; connector &#125;);</span><br><span class="line">    </span><br><span class="line">    WebAppContext bb = <span class="keyword">new</span> WebAppContext();</span><br><span class="line">    bb.setServer(server);</span><br><span class="line">    bb.setContextPath(<span class="string">"/solr"</span>);</span><br><span class="line">    bb.setWar(<span class="string">"webapp/web"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // START JMX SERVER</span></span><br><span class="line"><span class="comment">//    if( true ) &#123;</span></span><br><span class="line"><span class="comment">//      MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();</span></span><br><span class="line"><span class="comment">//      MBeanContainer mBeanContainer = new MBeanContainer(mBeanServer);</span></span><br><span class="line"><span class="comment">//      server.getContainer().addEventListener(mBeanContainer);</span></span><br><span class="line"><span class="comment">//      mBeanContainer.start();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    server.setHandler(bb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"&gt;&gt;&gt; STARTING EMBEDDED JETTY SERVER, PRESS ANY KEY TO STOP"</span>);</span><br><span class="line">      server.start();</span><br><span class="line">      <span class="keyword">while</span> (System.in.available() == <span class="number">0</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      server.stop();</span><br><span class="line">      server.join();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      System.exit(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="配置Solr-Home"><a href="#配置Solr-Home" class="headerlink" title="配置Solr Home"></a><font color="#2C3E50">配置Solr Home</font></h2><p>为了能够进行源码的bug，我们需要配置好solr_home,这里我们可以直接使用官方的Solr发行包中的example来做演示（真实的开发中，一般会有自己定义好的solr_home），直接下载solr的发行包(这里以solr-7.7.2为例子)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Documents</span><br><span class="line">curl <span class="string">"http://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/7.7.2/solr-7.7.2.tgz"</span> -o solr-7.7.2.tgz &amp;&amp; tar -xvf solr-7.7.2.tgz</span><br><span class="line">mkdir solr_home &amp;&amp; <span class="built_in">cd</span> solr_home</span><br><span class="line">cp ~/Documents/solr-7.7.2/server/solr/solr.xml ./</span><br><span class="line">cp -r ~/Documents/solr-7.7.2/server/solr/configsets/sample_techproducts_configs ./</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"collection=TEST"</span> &gt; sample_techproducts_configs/core.properties</span><br></pre></td></tr></table></figure></p><p>这里简单解释下最后一个命令(echo “collection=TEST …”)的含义,Solr中有collection和core的概念。</p><blockquote><ul><li>Collection<br>Solr中的collection由一个或者多个core组成，一个collection对应一份独立的config，在单节点的模式下，core和collection是等价的,在集群模式下，一个collection会有多个分片(shard)组成，每个分片又可以又多个副本(replica),每个shard对应一个core</li><li>core<br>Solr中的core是一个包含index和config的运行实例</li></ul></blockquote><h2 id="配置StartSolrJetty"><a href="#配置StartSolrJetty" class="headerlink" title="配置StartSolrJetty"></a><font color="#2C3E50">配置StartSolrJetty</font></h2><p>solr中的solr_home 可以通过通过环境变量进行设置，直接上代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"solr.solr.home"</span>, <span class="string">"/home/fql/Documents/solr_home"</span>);</span><br></pre></td></tr></table></figure></p><p>还有一个地方需要改动，否则程序无法正常启动，直接上代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bb.setWar(<span class="string">"webapp/web"</span>); ==&gt; bb.setWar(<span class="string">"solr/webapp/web"</span>);</span><br></pre></td></tr></table></figure></p><p>设置完毕之后就可以启动<strong>StartSolrJetty</strong>后直接在浏览器中输入<a href="http://127.0.0.1:8983/solr就可以开始畅游solr的源码啦.![本地访问](https://s2.ax1x.com/2019/10/02/udq8Tx.png)" target="_blank" rel="noopener">http://127.0.0.1:8983/solr就可以开始畅游solr的源码啦.![本地访问](https://s2.ax1x.com/2019/10/02/udq8Tx.png)</a></p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a><font color="#2C3E50">小技巧</font></h3><p>StartSolrJetty默认的配置是没有太多的日志输出的，但是既然我们都已经开始debug solr的源代码了，还是输出更多的日志帮助我们更好的分析源码吧，同样，开启debug日志的代码也比较简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"log4j2.debug"</span>,<span class="string">"true"</span>);</span><br></pre></td></tr></table></figure></p><p>这样我们就剋有看到所有的日志啦。下一篇我们将要介绍如果将修改过的solr源码部署到公司或者个人的nexus仓库,也是本系列的最后一篇。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;玩转Solr源码之–Solr源码Debug&quot;&gt;&lt;a href=&quot;#玩转Solr源码之–Solr源码Debug&quot; class=&quot;headerlink&quot; title=&quot;玩转Solr源码之–Solr源码Debug&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#0077bb&quot;&gt;玩转Solr源码之–Solr源码Debug&lt;/font&gt;&lt;/h1&gt;&lt;p&gt;这篇文章是&lt;strong&gt;玩转Solr源码&lt;/strong&gt;系列的第二篇，紧接着上一篇的&lt;a href=&quot;http://www.fengqinglei.top/2019/10/01/solr-source-code-import/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码导入&lt;/a&gt;，如果你还对如何将Solr源码导入到IDE还不了解的话，建议先看&lt;strong&gt;源码导入&lt;/strong&gt;的部分。&lt;/p&gt;
&lt;h2 id=&quot;定位源码入口&quot;&gt;&lt;a href=&quot;#定位源码入口&quot; class=&quot;headerlink&quot; title=&quot;定位源码入口&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#2C3E50&quot;&gt;定位源码入口&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;Solr 的源码入口为&lt;strong&gt;org.apache.solr.client.solrj.StartSolrJetty&lt;/strong&gt;,主方法也比较简短,&lt;br&gt;
    
    </summary>
    
    
      <category term="Solr" scheme="https://www.fengqinglei.top/tags/Solr/"/>
    
      <category term="源码" scheme="https://www.fengqinglei.top/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Debug" scheme="https://www.fengqinglei.top/tags/Debug/"/>
    
      <category term="调试" scheme="https://www.fengqinglei.top/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>玩转Solr源码之(一)Solr源码导入IDE</title>
    <link href="https://www.fengqinglei.top/2019/10/01/solr-source-code-import/"/>
    <id>https://www.fengqinglei.top/2019/10/01/solr-source-code-import/</id>
    <published>2019-10-01T07:47:33.000Z</published>
    <updated>2019-10-02T13:30:57.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="玩转Solr源码之–Solr源码导入IDE"><a href="#玩转Solr源码之–Solr源码导入IDE" class="headerlink" title="玩转Solr源码之–Solr源码导入IDE"></a><font color="#0077bb">玩转Solr源码之–Solr源码导入IDE</font></h1><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a><font color="#2C3E50">源码下载</font></h2><p>这个比较简单,直接到solr的官网上下载源码即可,这里以<a href="https://www.apache.org/dyn/closer.lua/lucene/solr/7.7.2/solr-7.7.2-src.tgz" target="_blank" rel="noopener">Solr 7.7.2</a>为例子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">"https://www.apache.org/dyn/closer.lua/lucene/solr/7.7.2/solr-7.7.2-src.tgz"</span> -o solr-7.7.2-src.tgz &amp;&amp; tar -xvf solr-7.7.2-src.tgz</span><br></pre></td></tr></table></figure></p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a><font color="#2C3E50">安装依赖</font></h2><blockquote><ul><li>jdk 1.8 </li><li>ant</li></ul></blockquote><p>笔者使用的是RedHat 系统，所以jdk的安装直接使用yum就行<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install  java-1.8.0-openjdk-devel.x86_64</span><br></pre></td></tr></table></figure></p><p>ant需要配置一下环境，也不算复杂<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">"http://mirrors.tuna.tsinghua.edu.cn/apache//ant/binaries/apache-ant-1.9.14-bin.tar.gz"</span> -o apache-ant-1.9.14-bin.tar.gz</span><br><span class="line">tar -xvf apache-ant-1.9.14-bin.tar.gz</span><br><span class="line">rm -rf apache-ant-1.9.14-bin.tar.gz</span><br></pre></td></tr></table></figure></p><p>配置环境变量(以RedHat为例),追加以下信息到~/.bash_profile (~/.bash_profile)，这里我把ant安装到了/opt目录下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ANT_HOME=/opt/apache-ant-1.9.14</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$ANT_HOME</span>/bin</span><br></pre></td></tr></table></figure></p><p>简单验证下，看到以下结果就算ok了(source ~/.bash_profile 是为了使刚刚的配置生效)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$source</span> ~/.bash_profile</span><br><span class="line"><span class="variable">$ant</span> -version</span><br><span class="line">Apache Ant(TM) version 1.9.14 compiled on March 12 2019</span><br></pre></td></tr></table></figure></p><h2 id="Build源码"><a href="#Build源码" class="headerlink" title="Build源码"></a><font color="#2C3E50">Build源码</font></h2><p>Solr的源码是使用ivy来管理依赖的，所以需要安装ivy的lib包，但是Solr的项目中可以通过<strong>ant ivy-bootstrap</strong>直接下载ivy的jar包,这里看到”BUILD SUCCESSFUL”表示执行成功了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> solr-7.7.2</span><br><span class="line"><span class="variable">$ant</span> ivy-bootstrap</span><br><span class="line">-ivy-bootstrap1:</span><br><span class="line">    [mkdir] Created dir: /home/fql/.ant/lib</span><br><span class="line">     [<span class="built_in">echo</span>] installing ivy 2.4.0 to /home/fql/.ant/lib</span><br><span class="line">      [get] Getting: https://repo1.maven.org/maven2/org/apache/ivy/ivy/2.4.0/ivy-2.4.0.jar</span><br><span class="line">      [get] To: /home/fql/.ant/lib/ivy-2.4.0.jar</span><br><span class="line">-ivy-bootstrap2:</span><br><span class="line">-ivy-checksum:</span><br><span class="line">-ivy-remove-old-versions:</span><br><span class="line">ivy-bootstrap:</span><br><span class="line">BUILD SUCCESSFUL</span><br></pre></td></tr></table></figure></p><h2 id="生成Intelij-Idea-Eclipse项目"><a href="#生成Intelij-Idea-Eclipse项目" class="headerlink" title="生成Intelij Idea/Eclipse项目"></a><font color="#2C3E50">生成Intelij Idea/Eclipse项目</font></h2><p>Intelij Idea 是笔者从2013年开始用的，之前用的都是Eclipse,这里不比较两个工具的好坏，能完成项目开发就行，这里以导入Intellij Idea 为例子 (如果是eclipse则为<strong>ant eclipse</strong>)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> solr-7.7.2</span><br><span class="line"><span class="variable">$ant</span> idea</span><br></pre></td></tr></table></figure></p><p>这个执行的过程比较长，是因为ivy会从maven的官方repo下载依赖,这里可以去喝杯茶等着程序自动执行完成就行.</p><h4 id="如何解决下载不了org-restlet打头的包"><a href="#如何解决下载不了org-restlet打头的包" class="headerlink" title="如何解决下载不了org.restlet打头的包"></a><font color="#2C3E50">如何解决下载不了org.restlet打头的包</font></h4><p>可能你在执行ant test的时候会遇到类似以下的错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">resolve:</span><br><span class="line">[ivy:retrieve] </span><br><span class="line">[ivy:retrieve] :: problems summary ::</span><br><span class="line">[ivy:retrieve] :::: WARNINGS</span><br><span class="line">[ivy:retrieve] [FAILED     ] org.restlet.jee#org.restlet;2.3.0!org.restlet.jar:  (0ms)</span><br><span class="line">[ivy:retrieve] ==== shared: tried</span><br><span class="line">[ivy:retrieve]   /home/fql/.ivy2/shared/org.restlet.jee/org.restlet/2.3.0/jars/org.restlet.jar</span><br><span class="line">[ivy:retrieve] ==== public: tried</span><br><span class="line">[ivy:retrieve]   https://repo1.maven.org/maven2/org/restlet/jee/org.restlet/2.3.0/org.restlet-2.3.0.jar</span><br><span class="line">[ivy:retrieve] [FAILED     ] org.restlet.jee#org.restlet.ext.servlet;2.3.0!org.restlet.ext.servlet.jar:  (0ms)</span><br><span class="line">[ivy:retrieve] ==== shared: tried</span><br><span class="line">[ivy:retrieve]   /home/fql/.ivy2/shared/org.restlet.jee/org.restlet.ext.servlet/2.3.0/jars/org.restlet.ext.servlet.jar</span><br><span class="line">[ivy:retrieve] ==== public: tried</span><br><span class="line">[ivy:retrieve]   https://repo1.maven.org/maven2/org/restlet/jee/org.restlet.ext.servlet/2.3.0/org.restlet.ext.servlet-2.3.0.jar</span><br><span class="line">[ivy:retrieve] ::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">[ivy:retrieve] ::              FAILED DOWNLOADS            ::</span><br><span class="line">[ivy:retrieve] :: ^ see resolution messages for details  ^ ::</span><br><span class="line">[ivy:retrieve] ::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">[ivy:retrieve] :: org.restlet.jee#org.restlet;2.3.0!org.restlet.jar</span><br><span class="line">[ivy:retrieve] :: org.restlet.jee#org.restlet.ext.servlet;2.3.0!org.restlet.ext.servlet.jar</span><br><span class="line">[ivy:retrieve] ::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">[ivy:retrieve] </span><br><span class="line">[ivy:retrieve] :: USE VERBOSE OR DEBUG MESSAGE LEVEL FOR MORE DETAILS</span><br><span class="line"></span><br><span class="line">BUILD FAILED</span><br><span class="line">/home/fql/IdeaProjects/solr-7.7.2/build.xml:140: The following error occurred while executing this line:</span><br><span class="line">/home/fql/IdeaProjects/solr-7.7.2/solr/build.xml:602: The following error occurred while executing this line:</span><br><span class="line">/home/fql/IdeaProjects/solr-7.7.2/solr/core/build.xml:68: impossible to resolve dependencies:</span><br><span class="line">resolve failed - see output for details</span><br></pre></td></tr></table></figure></p><p>这是因为这个依赖的目录已经在~/.ivy2/cache下面的目录生成了，但是jar下载失败导致的，直接删除对应的目录重新执行<strong>ant test</strong> 就行了,以上面的错误为例，具体执行的命令为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.ivy2/cache/org.restlet*</span><br><span class="line">ant <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><h2 id="导入Idea"><a href="#导入Idea" class="headerlink" title="导入Idea"></a><font color="#2C3E50">导入Idea</font></h2><p>执行完<strong>ant idea</strong>之后，如果看见以下类似输出表示build成功，我们可以开始将项目导入<strong>Intelij Idea</strong>了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-post-idea-instructions:</span><br><span class="line">     [echo] </span><br><span class="line">     [echo] To complete IntelliJ IDEA setup, you must manually configure</span><br><span class="line">     [echo] File | Project Structure | Project | Project SDK.</span><br><span class="line">     [echo]       </span><br><span class="line">     [echo] You won&apos;t have to do this in the future if you define property</span><br><span class="line">     [echo] $&#123;idea.jdk&#125;, e.g. in ~/lucene.build.properties, ~/build.properties</span><br><span class="line">     [echo] or lucene/build.properties, with a value consisting of the</span><br><span class="line">     [echo] following two XML attributes/values (adjust values according to</span><br><span class="line">     [echo] JDKs you have defined locally - see </span><br><span class="line">     [echo] File | Project Structure | Platform Settings | SDKs):</span><br><span class="line">     [echo] </span><br><span class="line">     [echo]     idea.jdk = project-jdk-name=&quot;1.8&quot; project-jdk-type=&quot;JavaSDK&quot;</span><br><span class="line">     [echo]     </span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br></pre></td></tr></table></figure></p><p>打开Intelij Idea , 选择文件-&gt;打开-&gt;选择源码的路径打开即可,Eclipse 直接选择从本地文件系统中打开项目即可。<br><img src="https://s2.ax1x.com/2019/10/01/uUfCDg.png" alt="项目导入"><br>至此，我们已经完成将项目导入到Intelij Idea，下面我会分享如何在Intelij Idea中debug Solr 的源码。</p><h2 id="参考的网址"><a href="#参考的网址" class="headerlink" title="参考的网址"></a><font color="#2C3E50">参考的网址</font></h2><blockquote><ul><li><a href="https://stackoverflow.com/questions/30630227/java-ivy-maven-build-dependency-resolution-for-lucidworks-auto-phrase-tokenizer" target="_blank" rel="noopener">https://stackoverflow.com/questions/30630227/java-ivy-maven-build-dependency-resolution-for-lucidworks-auto-phrase-tokenizer</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;玩转Solr源码之–Solr源码导入IDE&quot;&gt;&lt;a href=&quot;#玩转Solr源码之–Solr源码导入IDE&quot; class=&quot;headerlink&quot; title=&quot;玩转Solr源码之–Solr源码导入IDE&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#0077bb&quot;&gt;玩转Solr源码之–Solr源码导入IDE&lt;/font&gt;&lt;/h1&gt;&lt;h2 id=&quot;源码下载&quot;&gt;&lt;a href=&quot;#源码下载&quot; class=&quot;headerlink&quot; title=&quot;源码下载&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#2C3E50&quot;&gt;源码下载&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;这个比较简单,直接到solr的官网上下载源码即可,这里以&lt;a href=&quot;https://www.apache.org/dyn/closer.lua/lucene/solr/7.7.2/solr-7.7.2-src.tgz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Solr 7.7.2&lt;/a&gt;为例子。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl &lt;span class=&quot;string&quot;&gt;&quot;https://www.apache.org/dyn/closer.lua/lucene/solr/7.7.2/solr-7.7.2-src.tgz&quot;&lt;/span&gt; -o solr-7.7.2-src.tgz &amp;amp;&amp;amp; tar -xvf solr-7.7.2-src.tgz&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装依赖&quot;&gt;&lt;a href=&quot;#安装依赖&quot; class=&quot;headerlink&quot; title=&quot;安装依赖&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#2C3E50&quot;&gt;安装依赖&lt;/font&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;jdk 1.8 &lt;/li&gt;
&lt;li&gt;ant&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;笔者使用的是RedHat 系统，所以jdk的安装直接使用yum就行&lt;br&gt;
    
    </summary>
    
    
      <category term="Solr" scheme="https://www.fengqinglei.top/tags/Solr/"/>
    
      <category term="Intelij Idea" scheme="https://www.fengqinglei.top/tags/Intelij-Idea/"/>
    
      <category term="Eclipse" scheme="https://www.fengqinglei.top/tags/Eclipse/"/>
    
      <category term="源码" scheme="https://www.fengqinglei.top/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="ant" scheme="https://www.fengqinglei.top/tags/ant/"/>
    
  </entry>
  
  <entry>
    <title>IBM ICU 简繁转换工具的性能坑</title>
    <link href="https://www.fengqinglei.top/2019/07/21/IBMICUSlowIssue/"/>
    <id>https://www.fengqinglei.top/2019/07/21/IBMICUSlowIssue/</id>
    <published>2019-07-21T06:33:05.000Z</published>
    <updated>2019-09-27T00:46:01.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IBM-ICU-简繁转换工具的性能坑"><a href="#IBM-ICU-简繁转换工具的性能坑" class="headerlink" title="IBM ICU 简繁转换工具的性能坑"></a><font color="#0077bb">IBM ICU 简繁转换工具的性能坑</font></h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a><font color="#2C3E50">背景介绍</font></h2><p>由于工作内容的需要，我们处理的文本数据中会有繁体中文，但是我们的产品的使用客户都是习惯使用简体中文（台湾是中国不可割舍的一部分），所以为了方便用户使用简体中文检索到繁体中文，我们需要在建立索引的时候（这里以solr为例子）进行简繁转换。简单的查看了Solr的文档，以及简单的百度或者Google, 我们可以在Solr(7.7.2)中添加以下的字段类型来进行中文分词和简繁转换。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"test"</span>  <span class="attr">class</span>=<span class="string">"solr.TextField"</span> &gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">analyzer</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">charFilter</span> <span class="attr">class</span>=<span class="string">"solr.HTMLStripCharFilterFactory"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">charFilter</span> <span class="attr">class</span>=<span class="string">"solr.MappingCharFilterFactory"</span> <span class="attr">mapping</span>=<span class="string">"mapping-ISOLatin1Accent.txt"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"solr.StandardTokenizerFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.CJKWidthFilterFactory"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.ICUTransformFilterFactory"</span> <span class="attr">id</span>=<span class="string">"Traditional-Simplified"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.LowerCaseFilterFactory"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.CJKBigramFilterFactory"</span> <span class="attr">han</span>=<span class="string">"true"</span> <span class="attr">outputUnigrams</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以看到这是最简单的中文分词器-&gt; 二元分词，并且在二元的基础上输出了一元的结果，这里可以简单看下分词结果<br><img src="https://s2.ax1x.com/2019/07/21/eCmvwt.png" alt="二元+一元分词效果"><br>似乎配置+使用起来也就5s(666),但是实际情况是性能不够，射不高，跑不快。<br><a id="more"></a></p><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a><font color="#2C3E50">发现问题</font></h2><p>因为是需要上线的服务，所以习惯性的需要在本地进行一些索引和查询的性能测试，为了测试索引的性能，我准备了2700万的文档数据（包含简体中文和繁体中文），进行压缩之后这些文档大小在135GB左右，基本上可以做一个长时间的性能摸底测试了。<br>我们简单的看下用户测试的机器配置</p><div class="table-container"><table><thead><tr><th style="text-align:center">机器类型</th><th style="text-align:center">CPU 配置</th><th style="text-align:center">内存配置</th><th style="text-align:center">磁盘配置</th></tr></thead><tbody><tr><td style="text-align:center">Solr服务机器</td><td style="text-align:center">12 Core Intel(R) Xeon(R) CPU E5-2420 v2 @ 2.20GHz</td><td style="text-align:center">30GB</td><td style="text-align:center">7TB LVM</td></tr><tr><td style="text-align:center">索引机器</td><td style="text-align:center">4 Core Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz</td><td style="text-align:center">16GB</td><td style="text-align:center">1TB HDD</td></tr></tbody></table></div><p>并且<strong>索引机器</strong> 和 <strong>Solr 服务机器</strong> 之前的网络为千兆带宽，所以网络上不会成为瓶颈。<br>并且Solr 的一些重要配置为</p><blockquote><ul><li>内存配置为SOLR_JAVA_MEM=”-Xms6144m -Xmx6144m”</li><li><p>ramBufferSizeMB配置为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ramBufferSizeMB</span>&gt;</span>100<span class="tag">&lt;/<span class="name">ramBufferSizeMB</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>mergePolicyFactory 为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mergePolicyFactory</span> <span class="attr">class</span>=<span class="string">"org.apache.solr.index.TieredMergePolicyFactory"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">int</span> <span class="attr">name</span>=<span class="string">"maxMergeAtOnce"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">int</span> <span class="attr">name</span>=<span class="string">"segmentsPerTier"</span>&gt;</span>40<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">double</span> <span class="attr">name</span>=<span class="string">"noCFSRatio"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">double</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">int</span> <span class="attr">name</span>=<span class="string">"maxMergedSegmentMB"</span>&gt;</span>1024<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mergePolicyFactory</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>mergeScheduler 为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mergeScheduler</span> <span class="attr">class</span>=<span class="string">"org.apache.lucene.index.ConcurrentMergeScheduler"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">int</span> <span class="attr">name</span>=<span class="string">"maxMergeCount"</span>&gt;</span>12<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">int</span> <span class="attr">name</span>=<span class="string">"maxThreadCount"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mergeScheduler</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>autoCommit 的配置为 (防止频繁的autocommit生成太多的小段导致Solr一直在合并段)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">autoCommit</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">maxTime</span>&gt;</span>$&#123;solr.autoCommit.maxTime:180000&#125;<span class="tag">&lt;/<span class="name">maxTime</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">openSearcher</span>&gt;</span>false<span class="tag">&lt;/<span class="name">openSearcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">autoCommit</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><p>为了仅可能的用尽服务端的CPU，我在客户端开了20个线程往服务端丢数据，理论上应该可以将服务端的cpu跑满。但是实际的服务端cpu使用情况为<img src="https://s2.ax1x.com/2019/07/21/eCCX59.png" alt="Solr Server CPU usage"><br>并且客户端的索引速度只有<strong>404 doc/s</strong> (因为和具体的文档的大小和内容有关系，速度的值并没有太多的参考意义，我们需要观察的更多的速度的变化率)<br>显然这个结果（cpu使用率）和预期的相差非常大？为啥还有那么多的cpu资源在idl ？？</p><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a><font color="#2C3E50">定位问题</font></h2><p>为了搞清楚为啥会有这么多cpu在idl，最简单的办法就是使用一些jvm的profile工具，可以看到cpu把大量的资源消耗在什么地方，从而我们可以定位到发生问题的代码的类甚至某一行，这里我们使用的工具是<a href="https://visualvm.github.io/" target="_blank" rel="noopener">VisualVM</a>,当然为了能够让VisualVM能够访问服务端的jvm进程，我们需要对Solr进行一些配置，这个比较简单，主要是修改<strong>solr.in.sh</strong>文件的内容，直接上具体的配置点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SOLR_OPTS=<span class="string">"<span class="variable">$SOLR_OPTS</span> -Dcom.sun.management.jmxremote"</span></span><br><span class="line">SOLR_OPTS=<span class="string">"<span class="variable">$SOLR_OPTS</span> -Dcom.sun.management.jmxremote.port=28983"</span></span><br><span class="line">SOLR_OPTS=<span class="string">"<span class="variable">$SOLR_OPTS</span> -Dcom.sun.management.jmxremote.ssl=false"</span></span><br><span class="line">SOLR_OPTS=<span class="string">"<span class="variable">$SOLR_OPTS</span> -Dcom.sun.management.jmxremote.authenticate=false"</span></span><br><span class="line">SOLR_OPTS=<span class="string">"<span class="variable">$SOLR_OPTS</span> -Djava.rmi.server.hostname=192.168.18.2"</span></span><br></pre></td></tr></table></figure></p><p>重新开启服务端和客户端进行压力测试（之前的数据已经清理掉了），在程序运行了几分钟之后我们可以通过VisualVM的CPU profile功能发现，大量的cpu时间被消耗在了<strong>com.ibm.icu.text.RuleBasedTransliterator.handlerTransliterate()</strong> 方法上了,<br><img src="https://s2.ax1x.com/2019/07/21/eCeRVP.png" alt="VisualVM CPU Profile"><br>回想了下Solr的中的字段的定了中有个<strong>solr.ICUTransformFilterFactory</strong>filter，显然就是这个filter耗费了大量的cpu时间（看包名和类型就能联想到）,为了简单的验证是不是这个类导致的问题，我简单的做了下对比实验，我可以把这个filter注释掉看下服务端的cpu使用率和客户端的索引速度。直接修改schema中的field type定义<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"test"</span>  <span class="attr">class</span>=<span class="string">"solr.TextField"</span> &gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">analyzer</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">charFilter</span> <span class="attr">class</span>=<span class="string">"solr.HTMLStripCharFilterFactory"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">charFilter</span> <span class="attr">class</span>=<span class="string">"solr.MappingCharFilterFactory"</span> <span class="attr">mapping</span>=<span class="string">"mapping-ISOLatin1Accent.txt"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"solr.StandardTokenizerFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.CJKWidthFilterFactory"</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;filter class="solr.ICUTransformFilterFactory" id="Traditional-Simplified"/&gt; --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.LowerCaseFilterFactory"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.CJKBigramFilterFactory"</span> <span class="attr">han</span>=<span class="string">"true"</span> <span class="attr">outputUnigrams</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后重新开启服务端和客户端进行压力测试（之前的数据已经清理掉了），直接上cpu使用率和索引速度信息<br><img src="https://s2.ax1x.com/2019/07/21/eCAuWj.png" alt="Solr Server CPU usage"><br>并且客户端的索引速度也飙到了<strong>900 doc/s</strong>，尼玛坑爹的<strong>ICUTransformFilterFactory</strong>,搞个简繁转换还能搞出个幺蛾子，再看下VisualVM  的cpu profile结果<br><img src="https://s2.ax1x.com/2019/07/21/eCenH0.png" alt="VisualVM CPU Profile"><br>症状100%消失,更加肯定就是<strong>ICUTransformFilterFactory</strong>搞出来的幺蛾子，怎么弄个简繁转换还能出这种问题，弱爆了。。。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><font color="#2C3E50">源码分析</font></h2><p>为了100%确认真的是<strong>ICUTransformFilterFactory</strong>导致的问题，我下载了Solr-7.7.2的源代码，并且进行了源码的debug，<br>最终在<strong>com.ibm.icu.text.RuleBasedTransliterator.handlerTransliterate()</strong>中找到的真正的问题所在，废话不说上代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleTransliterate</span><span class="params">(Replaceable text, Position index, <span class="keyword">boolean</span> incremental)</span> </span>&#123;</span><br><span class="line">        RuleBasedTransliterator.Data var4 = <span class="keyword">this</span>.data;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.data) &#123;</span><br><span class="line">            <span class="keyword">int</span> loopCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> loopLimit = index.limit - index.start &lt;&lt; <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span>(loopLimit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                loopLimit = <span class="number">2147483647</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(index.start &lt; index.limit &amp;&amp; loopCount &lt;= loopLimit &amp;&amp; <span class="keyword">this</span>.data.ruleSet.transliterate(text, index, incremental)) &#123;</span><br><span class="line">                ++loopCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可见看见大大的<strong>synchronized</strong>关键字，难怪嘛，Solr的索引是多线程的，并且在看了ICU的一些初始化过程之后，在简繁转换这个case上的RuleBasedTransliterator.Data只用初始化一次就好，（具体的过程比较复杂，简单的来说这中简繁转换的rule来自于配置文件，显然配置文件不可能加载多次），所以一旦上了多线程就各种卡，cpu全消耗在内斗上了，哎。。。。，不过好消息是这个<strong>RuleBasedTransliterator</strong>类已经被打上了<strong>Deprecated</strong>标签了，所以估计在高版本的icu api中这个问题会不复存在。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><font color="#2C3E50">解决方案</font></h2><p>最简单的解决方案就是等—&gt; 等官方干掉这个类，这样期待在未来的版本中icu不再使用这个坑爹的<strong>synchronized</strong>关键字，当然这显然不是最好的版本，当然还有一种相对简单的方案就是直接干掉<strong>synchronized</strong>关键字，然后重新编译打包一下就好，如果只是为了写这篇博客确实可以这么干，因为后期的维护成本为0，但是在真是的企业开发中还是不太可取的，如果solr今后版本升级，我们也要下载对应的icu包然后去掉<strong>synchronized</strong>关键字，然后在重新编译打包等操作，虽然说是一次性工作，但是相当于我们间接的在维护icu的源码了。<br>还有一种最暴力的做法，但是却是我比较推荐的做法，我们可以自己造一个简繁转换的solrplugin，确实，只是简单的简体中文到繁体中文的转换，我们只需要找到简繁的对照表就可以做了。说干就干，我直接提取了icu包中的简体中文和繁体中文的对照表（当然获取途径有多种，甚至wiki上都有），这里是我提取的<a href="https://github.com/fengqingleiyue/apache-solr-plugins/blob/master/zh-converter/src/main/resources/hant_hans.properties" target="_blank" rel="noopener">简体繁体对照表</a>,有了简繁转换表，那么solrplugin也就相对简单了，不多说，直接上<a href="https://github.com/fengqingleiyue/apache-solr-plugins/tree/master/zh-converter" target="_blank" rel="noopener">代码</a>,为了验证问题是否解决，我简单做了下对比测试，索引速度直接从原来的<strong>401/s</strong>上升到了<strong>936/s</strong> ,服务端的cpu使用率也能够飙升至<strong>90%</strong>左右，直接上图<img src="https://s2.ax1x.com/2019/08/18/mlPsMT.png" alt="Solr Server CPU Usage">至此icu导致的性能问题，已经得到解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IBM-ICU-简繁转换工具的性能坑&quot;&gt;&lt;a href=&quot;#IBM-ICU-简繁转换工具的性能坑&quot; class=&quot;headerlink&quot; title=&quot;IBM ICU 简繁转换工具的性能坑&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#0077bb&quot;&gt;IBM ICU 简繁转换工具的性能坑&lt;/font&gt;&lt;/h1&gt;&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#2C3E50&quot;&gt;背景介绍&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;由于工作内容的需要，我们处理的文本数据中会有繁体中文，但是我们的产品的使用客户都是习惯使用简体中文（台湾是中国不可割舍的一部分），所以为了方便用户使用简体中文检索到繁体中文，我们需要在建立索引的时候（这里以solr为例子）进行简繁转换。简单的查看了Solr的文档，以及简单的百度或者Google, 我们可以在Solr(7.7.2)中添加以下的字段类型来进行中文分词和简繁转换。&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;fieldType&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;test&quot;&lt;/span&gt;  &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;solr.TextField&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;analyzer&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;charFilter&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;solr.HTMLStripCharFilterFactory&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;charFilter&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;solr.MappingCharFilterFactory&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;mapping&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;mapping-ISOLatin1Accent.txt&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;tokenizer&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;solr.StandardTokenizerFactory&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;solr.CJKWidthFilterFactory&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;solr.ICUTransformFilterFactory&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Traditional-Simplified&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;solr.LowerCaseFilterFactory&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;solr.CJKBigramFilterFactory&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;han&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;outputUnigrams&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;analyzer&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;fieldType&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到这是最简单的中文分词器-&amp;gt; 二元分词，并且在二元的基础上输出了一元的结果，这里可以简单看下分词结果&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/21/eCmvwt.png&quot; alt=&quot;二元+一元分词效果&quot;&gt;&lt;br&gt;似乎配置+使用起来也就5s(666),但是实际情况是性能不够，射不高，跑不快。&lt;br&gt;
    
    </summary>
    
    
      <category term="Solr" scheme="https://www.fengqinglei.top/tags/Solr/"/>
    
      <category term="IBM ICU" scheme="https://www.fengqinglei.top/tags/IBM-ICU/"/>
    
      <category term="Traditional-Simplified" scheme="https://www.fengqinglei.top/tags/Traditional-Simplified/"/>
    
      <category term="Performance" scheme="https://www.fengqinglei.top/tags/Performance/"/>
    
      <category term="性能调优" scheme="https://www.fengqinglei.top/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>如何动态设置Solr Payload</title>
    <link href="https://www.fengqinglei.top/2019/07/10/SolrPayLoads/"/>
    <id>https://www.fengqinglei.top/2019/07/10/SolrPayLoads/</id>
    <published>2019-07-10T15:05:22.000Z</published>
    <updated>2019-09-27T00:41:27.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何动态设置Solr-Payload"><a href="#如何动态设置Solr-Payload" class="headerlink" title="如何动态设置Solr Payload "></a><font color="#0077bb">如何动态设置Solr Payload </font></h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a><font color="#2C3E50">问题背景</font></h2><p>Solr 从6.x开始提供了index payload的功能，（payload是指可以指定为分词之后的每个term指定一个二进制的信息，用于针对每个term作出一定的行为，例如可以用来存储指定的score用于排序，也可以用来存储指定的数据，用于检查term的一定的检查），简单的查阅官方文档之后（这里使用solr7.7.2作为样例）,得知我们可以动态的设定每个term的payload（参考<a href="https://lucidworks.com/post/end-to-end-payload-example-in-solr/" target="_blank" rel="noopener">SolrPayload</a>），也可以根据指定的token type设置payload数值(参考<a href="https://lucene.apache.org/solr/guide/7_4/filter-descriptions.html#numeric-payload-token-filter" target="_blank" rel="noopener">Numeric Payload Token Filter</a>)，但是上述两种方式都无法根据输入的变化而动态的改变payload的值。<br><a id="more"></a></p><h3 id="具体需求"><a href="#具体需求" class="headerlink" title="具体需求"></a><font color="#2C3E50">具体需求</font></h3><p>由于和具体的的业务有关，我这里将需求简单化。</p><blockquote><ul><li>业务中的字段类型为多值字段</li><li>同一篇文档的多值字段中不同的数值需要设置不同的payload</li><li>需要更具不同的参数设定不同的payload数值</li></ul></blockquote><p>看到这里老司机肯定说这个需求太简单了，直接使用<strong>Numeric Payload Token Filter</strong> 就行了，可以将多值字段放到多个字段中，每个字段指定不同的payload的问题也可以解决啊 (只需要指定不同字段类型下面例子中的payload值就行了)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;analyzer&gt;</span><br><span class="line">  &lt;tokenizer class=&quot;solr.WhitespaceTokenizerFactory&quot;/&gt;</span><br><span class="line">  &lt;filter class=&quot;solr.NumericPayloadTokenFilterFactory&quot; payload=&quot;0.75&quot; typeMatch=&quot;word&quot;/&gt;</span><br><span class="line">&lt;/analyzer&gt;</span><br></pre></td></tr></table></figure></p><p>确实，在多值字段的值的个数较少的时候我也推荐这种做法，因为相对比较简单，而且容易操作。但是如果我有多值字段有20个值，那么这样我的schema里面必须得有20个字段类型，20个字段来对应的多个payload ,那么管理这20个字段就变成了一件蛋疼的事情。<br>当然这里也有人会说为啥不用solr的<strong>DelimitedPayloadTokenFilter</strong>(<a href="https://lucidworks.com/post/solr-payloads/）" target="_blank" rel="noopener">用法可以参考</a>,我们可以手动指定每个term的payload，例如 (分隔符|后面的数字为payload)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id,vals_dpf</span><br><span class="line">1,one|1.0 two|2.0 three|3.0</span><br><span class="line">2,weighted|50.0 weighted|100.0</span><br></pre></td></tr></table></figure></p><p>是的，确实可以，但是前提是你的文档内容比较简单（内容简单的话推荐使用<strong>DelimitedPayloadTokenFilter</strong>,可以在index代码中根据业务动态控制），如果文档比较复杂，比如就是一段文本，那么相当于你得在index代码中将文本进行分词然后拼接成上述的例子，但是如果拼接的话solr的分词功能就形同摆设了，那么有没有办法既能保持index代码的简单性，也可以使用solr的分词功能来完成上述的需求呢？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><font color="#2C3E50">解决方案</font></h2><p>解决方案其实只有两步</p><blockquote><ul><li>可以动态的设置某个字段的某个值的某个属性</li><li>自定Tokenizer或者filter根据某个属性设定对用的payload</li></ul></blockquote><p>(我去，这简直就是正确的废话)<br>那么既然我们的“解决方案”已经有了，我们该怎么一步步的实现这个“解决方案呢”，我们来一步步分析下，</p><blockquote><ul><li>我们怎么动态的设置某个字段的某个值的某个属性？</li></ul></blockquote><p>由于在index的代码中，Solr的给我们的API比较简单，直接就是 SolrInputDocument.set(fieldname,fieldvalue),我们能控制的要么就是fieldname，要么就是fieldvalue， 控制fieldname的方案我前面已经介绍过,可以使用<strong>Numeric Payload Token Filter</strong> 来解决我们的问题，这里我们可能设法在fieldname上做文章了，那么可以选择的方案只能是在fieldvalue上下功夫了，显然，我们只能在fieldvalue的头上加一些特殊的标记来解决问题，当然这些特殊的标记不能和你的字段值的某个或者某些特征发生冲突，例如我们可以在字段值的前段加上”[|xxx|]”,那么我们就可以在更具xxx的内容设定某个字段的某个属性就行了</p><blockquote><ul><li>如何在solr端读取xxx的内容？</li></ul></blockquote><p>solr的index功能是基于Lucene提供的，那么Lucene给我的api也比较简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Document doc = new Document();</span><br><span class="line">doc.add(new StringField(&quot;fieldName&quot;,&quot;document context&quot;, Field.Store.YES));</span><br></pre></td></tr></table></figure></p><p>也就是所有的文档的字段到lucene这一层肯定都是转成一个document，然后向文档里面添加对应的字段，不同的字段使用不同的分词器来进行分词，对，我们可以自定义字段，在生成这个字段的时候解析<strong>xxx</strong>的内容，并且根据<strong>xxx</strong>的内容设定某个属性的值问题不就能解决了吗？<br>简单的翻看了Solr的某个字段类型的源码（这里以<strong>Solr.TextField</strong>为例子）<br><img src="https://s2.ax1x.com/2019/07/21/epDlO1.png" alt="Solr.TextField Method List"> ,都是一些get方法，貌似没啥用，看看父类<strong>org.apache.solr.schema.FieldType</strong><br><img src="https://s2.ax1x.com/2019/07/21/epDVoT.png" alt="FieldType Method List"><br>貌似<strong>createField</strong>就是我们要找的方法，我们可以在这里解析fieldvalue ,并且根据<strong>xxx</strong>设置这个字段的某个属性，然后拿掉<strong>xxx</strong>,还原原始的fieldvalue</p><blockquote><ul><li>“某个属性”到底是哪个属性</li></ul></blockquote><p>在上文中我们一直提到“某个属性”，但是我们到目前为止还是没有找到这个可以设置的属性到底是啥，但是如果我们不找到这个属性，上面的分析过程全是扯淡的，为了找到这个属性，我们必须知道这个属性满足什么样的特征呢，我们分析下这个属性需要满足的特征</p><blockquote><blockquote><ul><li>这个属性不能对原始的fieldvalue产生变更</li></ul></blockquote></blockquote><p>为什么？按照我们的想法，这个”某个属性“不能对原始的fieldvalue参数影响，如果改变了原始value，</p><blockquote><blockquote><ul><li>这个属性可以必须是跟着term走的，并且可以在tokenizer和filter中可以获取</li></ul></blockquote></blockquote><p>为什么？按照我们的做法，我们必须在某个tokenizer或者filter或者这个属性，才能设置payload的值，其他的地方没发接触到payload </p><p>明确了上述两个特征，我们找个filter／tokenizer的源代码看下 ,找个最简单的<strong>LowerCaseFilter</strong> 看看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowerCaseFilter</span> <span class="keyword">extends</span> <span class="title">TokenFilter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create a new LowerCaseFilter, that normalizes token text to lower case.</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> in TokenStream to filter</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LowerCaseFilter</span><span class="params">(TokenStream in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(in);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">incrementToken</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input.incrementToken()) &#123;</span><br><span class="line">      CharacterUtils.toLowerCase(termAtt.buffer(), <span class="number">0</span>, termAtt.length());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里我们有了答案，原来CharTermAttribute就是Lucene／Solr原来在设定某个term的值的，那么我们可以自己造一个，放入根据<strong>xxx</strong>得到的属性，然后在filter里面或者这个属性，不就可以动态的设定payload的值了嘛， 对头， 上代码 </p><blockquote><ul><li>自定义Solr的Field </li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicPayloadsField</span> <span class="keyword">extends</span> <span class="title">TextField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IndexableField <span class="title">createField</span><span class="params">(SchemaField field, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!field.indexed() &amp;&amp; !field.stored()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled())</span><br><span class="line">                log.trace(<span class="string">"Ignoring unindexed/unstored field: "</span> + field);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String val;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            val = toInternal(value.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SolrException( SolrException.ErrorCode.SERVER_ERROR, <span class="string">"Error while creating field '"</span> + field + <span class="string">"' from value '"</span> + value + <span class="string">"'"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String target = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (val.startsWith(<span class="string">"[|"</span>) &amp;&amp; val.contains(<span class="string">"|]"</span>)) &#123;</span><br><span class="line">            target = val.substring(<span class="number">2</span>,val.indexOf(<span class="string">"|]"</span>));</span><br><span class="line">            <span class="keyword">if</span> (DynamicPayloadAttribute.FIELD_MAPPINGS.containsKey(target)) &#123;</span><br><span class="line">                String parsedData = val.substring(val.indexOf(<span class="string">"|]"</span>)+<span class="number">2</span>);</span><br><span class="line">                TokenizerChain tokenizerChain = (TokenizerChain)field.getType().getIndexAnalyzer();</span><br><span class="line">                Tokenizer tk = tokenizerChain.getTokenizerFactory().create(TokenStream.DEFAULT_TOKEN_ATTRIBUTE_FACTORY);</span><br><span class="line">                TokenStream ts = tk;</span><br><span class="line">                <span class="keyword">for</span> (TokenFilterFactory filter : tokenizerChain.getTokenFilterFactories()) &#123;</span><br><span class="line">                    ts = filter.create(ts);</span><br><span class="line">                &#125;</span><br><span class="line">                Analyzer.TokenStreamComponents components = <span class="keyword">new</span> Analyzer.TokenStreamComponents(tk, ts);</span><br><span class="line">                Reader stringReader = tokenizerChain.initReader(field.getName(),<span class="keyword">new</span> StringReader(parsedData));</span><br><span class="line">                tk.setReader(stringReader);</span><br><span class="line">                TokenStream stream = components.getTokenStream();</span><br><span class="line">                stream.getAttribute(DynamicPayloadAttribute.class).setPayloadType(target);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Field(field.getName(), stream, field);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.createField(field.getName(), val, field);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.createField(field.getName(), val, field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>自定义Attribute</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DynamicPayloadAttribute</span> <span class="keyword">extends</span> <span class="title">Attribute</span> </span>&#123;</span><br><span class="line">    Map&lt;String,Integer&gt; FIELD_MAPPINGS = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            put(<span class="string">"A"</span>,<span class="number">0</span>);</span><br><span class="line">            put(<span class="string">"B"</span>,<span class="number">1</span>);</span><br><span class="line">            put(<span class="string">"C"</span>,<span class="number">2</span>);</span><br><span class="line">            put(<span class="string">"D"</span>,<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    String DEFAULT_PAYLOAD_TYPE = <span class="string">"UNKNOW_PAYLOAD_TYPE"</span>;</span><br><span class="line">    <span class="function">String <span class="title">payloadType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPayloadType</span><span class="params">(String type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">byte</span> <span class="title">getPayLoad</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>自定义filter</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicPayloadTokenFilter</span> <span class="keyword">extends</span> <span class="title">TokenFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayloadAttribute payAtt = addAttribute(PayloadAttribute.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DynamicPayloadAttribute dypayAtt = addAttribute(DynamicPayloadAttribute.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DynamicPayloadTokenFilter</span><span class="params">(TokenStream input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">incrementToken</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input.incrementToken()) &#123;</span><br><span class="line">            <span class="keyword">byte</span> payload = dypayAtt.getPayLoad();</span><br><span class="line">            <span class="keyword">if</span>(payload==Byte.MAX_VALUE)&#123;</span><br><span class="line">                payAtt.setPayload(<span class="keyword">null</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span> array [] = &#123;payload&#125;;</span><br><span class="line">                payAtt.setPayload(<span class="keyword">new</span> BytesRef(array));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我只放上了重要的代码片段，完整的代码请参考<a href="https://github.com/fengqingleiyue/apache-solr-plugins/tree/master/dynamic-payload" target="_blank" rel="noopener">apache-solr-plugins/dynamic-payload</a></p><h2 id="爬坑指南"><a href="#爬坑指南" class="headerlink" title="爬坑指南"></a><font color="#2C3E50">爬坑指南</font></h2><p>当然如果所有的细节都如上述描述那么简单，那么各位看官肯定觉得无聊死了，所有的程序员朋友们肯定更加关注这个过程中有没有什么坑，当然坑是存在的，坑是痛苦的，爬坑的过程是痛苦的，爬坑是需要分享的。<br>遇到的坑:<br>在Solr的<a href="http://127.0.0.1:8983/solr/#/TEST/documents" target="_blank" rel="noopener">document</a>页面上添加文档是成功的，但是一旦用代码上多线程立马报错（主要的错误就是TokenStream 在调用前没有调用reset方法）<br>在没有修正这个问题之前的<strong>createField</strong>的方法实现为（部分）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (val.startsWith(<span class="string">"[|"</span>) &amp;&amp; val.contains(<span class="string">"|]"</span>)) &#123;</span><br><span class="line">           target = val.substring(<span class="number">2</span>,val.indexOf(<span class="string">"|]"</span>));</span><br><span class="line">           <span class="keyword">if</span> (DynamicPayloadAttribute.FIELD_MAPPINGS.containsKey(target)) &#123;</span><br><span class="line">               String parsedData = val.substring(val.indexOf(<span class="string">"|]"</span>)+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">               TokenStream stream = field.getType().getIndexAnalyzer().tokenStream(field.getName(),parsedData);</span><br><span class="line">               stream.addAttributeImpl(<span class="keyword">new</span> DynamicPayloadAttributeImpl(target));</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> Field(field.getName(),stream,field);</span><br></pre></td></tr></table></figure></p><p>而问题就出现在tokenStream方法上<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">field.getType().getIndexAnalyzer().tokenStream(field.getName(),parsedData);</span><br></pre></td></tr></table></figure></p><p>进入实现可以看到TokenStreamComponents是会重用的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TokenStream <span class="title">tokenStream</span><span class="params">(String fieldName, String text)</span> </span>&#123;</span><br><span class="line">        Analyzer.TokenStreamComponents components = <span class="keyword">this</span>.reuseStrategy.getReusableComponents(<span class="keyword">this</span>, fieldName);</span><br><span class="line">        ReusableStringReader strReader = components != <span class="keyword">null</span> &amp;&amp; components.reusableStringReader != <span class="keyword">null</span>?components.reusableStringReader:<span class="keyword">new</span> ReusableStringReader();</span><br><span class="line">        strReader.setValue(text);</span><br><span class="line">        Reader r = <span class="keyword">this</span>.initReader(fieldName, strReader);</span><br><span class="line">        <span class="keyword">if</span>(components == <span class="keyword">null</span>) &#123;</span><br><span class="line">            components = <span class="keyword">this</span>.createComponents(fieldName);</span><br><span class="line">            <span class="keyword">this</span>.reuseStrategy.setReusableComponents(<span class="keyword">this</span>, fieldName, components);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        components.setReader(r);</span><br><span class="line">        components.reusableStringReader = strReader;</span><br><span class="line">        <span class="keyword">return</span> components.getTokenStream();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这样做的好处就是不用重复生成tokenstream compents，并且不同的只是输入，其他的都是一样的，但是为啥在我们的应用场景就会报错呢，原来错误不再我们的使用方式上，而是在solr的后续的流程中会调用<strong>Field.tokenStream</strong>方法，并且在<strong>tokenStream</strong>属性不为空的情况下，就会直接return，所以想象下，如果同一个字段的不同值公用了同一个tokenstream属性，那么针对这个tokenstream设定的不同值，只会在最后一个调用的属性会成功。（显然这和我们的期望相违背）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TokenStream <span class="title">tokenStream</span><span class="params">(Analyzer analyzer, TokenStream reuse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.fieldType().indexOptions() == IndexOptions.NONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="keyword">this</span>.fieldType().tokenized()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.stringValue() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!(reuse <span class="keyword">instanceof</span> Field.StringTokenStream)) &#123;</span><br><span class="line">                    reuse = <span class="keyword">new</span> Field.StringTokenStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ((Field.StringTokenStream)reuse).setValue(<span class="keyword">this</span>.stringValue());</span><br><span class="line">                <span class="keyword">return</span> (TokenStream)reuse;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.binaryValue() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!(reuse <span class="keyword">instanceof</span> Field.BinaryTokenStream)) &#123;</span><br><span class="line">                    reuse = <span class="keyword">new</span> Field.BinaryTokenStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ((Field.BinaryTokenStream)reuse).setValue(<span class="keyword">this</span>.binaryValue());</span><br><span class="line">                <span class="keyword">return</span> (TokenStream)reuse;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Non-Tokenized Fields must have a String value"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.tokenStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.tokenStream;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.readerValue() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> analyzer.tokenStream(<span class="keyword">this</span>.name(), <span class="keyword">this</span>.readerValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.stringValue() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> analyzer.tokenStream(<span class="keyword">this</span>.name(), <span class="keyword">this</span>.stringValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Field must have either TokenStream, String, Reader or Number value; got "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>但是即使这样，也不应该会报错，原来如果在create field字段中调用<strong>tokenstream</strong>方法，那么针对多值字段，那么同一个<strong>tokenstream</strong>对象就有可能可能共享，那么当Solr处理完第一个值结束的时候会将tokenstream进行重制，那么原有的reader就会失效，那么当Solr开始处理第二个值的时候由于共享的同一个tokenstream,那么对用的reader已经失效，就会抛出错误。所以我们需要每次生成不同的tokenstream就可以解决问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (val.startsWith(<span class="string">"[|"</span>) &amp;&amp; val.contains(<span class="string">"|]"</span>)) &#123;</span><br><span class="line">            target = val.substring(<span class="number">2</span>,val.indexOf(<span class="string">"|]"</span>));</span><br><span class="line">            <span class="keyword">if</span> (DynamicPayloadAttribute.FIELD_MAPPINGS.containsKey(target)) &#123;</span><br><span class="line">                String parsedData = val.substring(val.indexOf(<span class="string">"|]"</span>)+<span class="number">2</span>);</span><br><span class="line">                TokenizerChain tokenizerChain = (TokenizerChain)field.getType().getIndexAnalyzer();</span><br><span class="line">                Tokenizer tk = tokenizerChain.getTokenizerFactory().create(TokenStream.DEFAULT_TOKEN_ATTRIBUTE_FACTORY);</span><br><span class="line">                TokenStream ts = tk;</span><br><span class="line">                <span class="keyword">for</span> (TokenFilterFactory filter : tokenizerChain.getTokenFilterFactories()) &#123;</span><br><span class="line">                    ts = filter.create(ts);</span><br><span class="line">                &#125;</span><br><span class="line">                Analyzer.TokenStreamComponents components = <span class="keyword">new</span> Analyzer.TokenStreamComponents(tk, ts);</span><br><span class="line">                Reader stringReader = tokenizerChain.initReader(field.getName(),<span class="keyword">new</span> StringReader(parsedData));</span><br><span class="line">                tk.setReader(stringReader);</span><br><span class="line">                TokenStream stream = components.getTokenStream();</span><br><span class="line">                stream.getAttribute(DynamicPayloadAttribute.class).setPayloadType(target);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Field(field.getName(), stream, field);</span><br></pre></td></tr></table></figure></p><h2 id="参考的项目或者文章"><a href="#参考的项目或者文章" class="headerlink" title="参考的项目或者文章"></a><font color="#2C3E50">参考的项目或者文章</font></h2><p><a href="https://lucidworks.com/post/solr-payloads/" target="_blank" rel="noopener">SolrPayload 功能 Example</a><br><a href="https://lucene.apache.org/solr/guide/7_4/filter-descriptions.html#numeric-payload-token-filter" target="_blank" rel="noopener">Solr Numeric Payload Token Filter</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何动态设置Solr-Payload&quot;&gt;&lt;a href=&quot;#如何动态设置Solr-Payload&quot; class=&quot;headerlink&quot; title=&quot;如何动态设置Solr Payload &quot;&gt;&lt;/a&gt;&lt;font color=&quot;#0077bb&quot;&gt;如何动态设置Solr Payload &lt;/font&gt;&lt;/h1&gt;&lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#2C3E50&quot;&gt;问题背景&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;Solr 从6.x开始提供了index payload的功能，（payload是指可以指定为分词之后的每个term指定一个二进制的信息，用于针对每个term作出一定的行为，例如可以用来存储指定的score用于排序，也可以用来存储指定的数据，用于检查term的一定的检查），简单的查阅官方文档之后（这里使用solr7.7.2作为样例）,得知我们可以动态的设定每个term的payload（参考&lt;a href=&quot;https://lucidworks.com/post/end-to-end-payload-example-in-solr/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SolrPayload&lt;/a&gt;），也可以根据指定的token type设置payload数值(参考&lt;a href=&quot;https://lucene.apache.org/solr/guide/7_4/filter-descriptions.html#numeric-payload-token-filter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Numeric Payload Token Filter&lt;/a&gt;)，但是上述两种方式都无法根据输入的变化而动态的改变payload的值。&lt;br&gt;
    
    </summary>
    
    
      <category term="Solr" scheme="https://www.fengqinglei.top/tags/Solr/"/>
    
      <category term="Payload" scheme="https://www.fengqinglei.top/tags/Payload/"/>
    
      <category term="动态设置" scheme="https://www.fengqinglei.top/tags/%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE/"/>
    
      <category term="Dynamic" scheme="https://www.fengqinglei.top/tags/Dynamic/"/>
    
      <category term="Lucene" scheme="https://www.fengqinglei.top/tags/Lucene/"/>
    
  </entry>
  
</feed>
